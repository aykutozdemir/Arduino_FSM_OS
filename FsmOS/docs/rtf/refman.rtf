{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment FsmOS  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.3.0 \par
}}FsmOS}
{\comment Generated by doxygen 1.9.8.}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt FsmOS}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 1.3.0\par\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\par \pard\plain 
\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
FsmOS - Arduino Finite State Machine Operating System\par \pard\plain 
{\tc\tcl1 \v FsmOS - Arduino Finite State Machine Operating System}
{\xe \v FsmOS - Arduino Finite State Machine Operating System}
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
 A lightweight, cooperative task scheduler for Arduino that helps you organize your code into independent tasks and manage communication between them. This library is perfect for projects that need to handle multiple operations without blocking or complex interrupt management.\par
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Key Features} \par}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Cooperative Multitasking} : Run multiple tasks without preemption\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Message Passing} : Inter-task communication with publish/subscribe (type + arg only)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Memory Efficient} : Optimized for AVR microcontrollers with accurate memory reporting\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Debug Support} : Built-in logging and diagnostics with formatted output\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b {\b Task} Budgeting} : Prevent message queue overruns with per-task message budgets\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Memory Monitoring} : Real-time RAM, stack, heap, flash, and EEPROM usage tracking\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Stack Canary Protection} : Automatic stack overflow detection\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Memory Leak Detection} : Built-in memory allocation tracking\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b {\b Task} Limit Control} : Configurable maximum task count based on topic bitfield size\par}
\par
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Installation} \par}
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Arduino IDE Library Manager (Recommended)} \par}
{
\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab Open Arduino IDE\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
2.\tab Go to {\f2 Sketch > Include Library > Manage Libraries...} \par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
3.\tab Search for "FsmOS"\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
4.\tab Click Install\par}
\par
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Manual Installation} \par}
{
\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab Download this repository\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
2.\tab Copy the {\f2 FsmOS}  folder to your Arduino libraries directory\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
3.\tab Restart Arduino IDE\par}
\par
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Quick Start} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf21 #include <FsmOS.h>}\par
\par
{\cf20 // Define a simple blinking task}\par
{\cf17 class }BlinkTask : {\cf17 public} Task\par
\{\par
{\cf17 public}:\par
    BlinkTask() : Task(F({\cf22 "Blinker"}))\par
    \{\par
        set_period(500);  {\cf20 // Run every 500ms}\par
    \}\par
\par
    uint8_t getMaxMessageBudget(){\cf17  const override }\{ {\cf19 return} 0; \}\par
    uint16_t getTaskStructSize(){\cf17  const override }\{ {\cf19 return} {\cf17 sizeof}(*this); \}\par
\par
    {\cf18 void} on_start(){\cf17  override}\par
{\cf17     }\{\par
        pinMode(LED_BUILTIN, OUTPUT);\par
        logInfo(F({\cf22 "Blink task started"}));\par
    \}\par
\par
    {\cf18 void} step(){\cf17  override}\par
{\cf17     }\{\par
        digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));\par
    \}\par
\};\par
\par
BlinkTask blinker;\par
\par
{\cf18 void} setup()\par
\{\par
    Serial.begin(9600);\par
    OS.begin_with_logger();  {\cf20 // Initialize with logging}\par
    OS.add(&blinker);\par
\}\par
\par
{\cf18 void} loop()\par
\{\par
    OS.loop_once();\par
\}\par
}
\par
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Examples} \par}
Check the {\f2 examples}  folder for more demonstrations:{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 BasicBlink} : Simple LED blinking task\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 ButtonLed} : Inter-task communication with publish/subscribe\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 Diagnostics} : System monitoring and debugging\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 Logger} : Using the built-in logging system with different levels\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 MemoryMonitoring} : Comprehensive memory usage tracking\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 MemoryOptimization} : Memory-efficient coding practices\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 MemoryOptimizedTimers} : Timer usage optimization\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 MessageQueueing} : Message handling during task suspension\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 TaskLifecycle} : {\b Task} state management\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 DynamicTasks} : Runtime task creation/deletion\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 TaskNames} : Named tasks and state tracking\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 MutexExample} : Mutual exclusion synchronization\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 SemaphoreExample} : Semaphore-based synchronization\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 TaskTimingMonitoring} : {\b Task} execution timing analysis\par}
\par
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Key Concepts} \par}
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 {\b Task} Structure} \par}
Every task must implement two pure virtual methods: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid uint8_t getMaxMessageBudget(){\cf17  const override }\{ {\cf19 return} X; \}  {\cf20 // Max messages per step}\par
uint16_t getTaskStructSize(){\cf17  const override }\{ {\cf19 return} {\cf17 sizeof}(*this); \}  {\cf20 // Memory tracking}\par
}
\par
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Message System} \par}
FsmOS uses a simplified message system with only type and argument data: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf20 // Publish a message}\par
publish(TOPIC_LED_EVENTS, EVT_LED_ON, 1);  {\cf20 // topic, type, arg}\par
\par
{\cf20 // Handle messages}\par
{\cf18 void} on_msg({\cf17 const} MsgData &msg){\cf17  override}\par
{\cf17 }\{\par
    {\cf19 switch} (msg.type)\par
    \{\par
        {\cf19 case} EVT_LED_ON:\par
            digitalWrite(LED_PIN, msg.arg);\par
            {\cf19 break};\par
    \}\par
\}\par
}
\par
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Message Budgeting} \par}
Tasks declare their maximum message production budget. The scheduler ensures sufficient queue space before execution: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf20 // Button task that publishes events}\par
uint8_t getMaxMessageBudget(){\cf17  const override }\{ {\cf19 return} 2; \}  {\cf20 // Press + Release}\par
\par
{\cf20 // LED task that only receives}\par
uint8_t getMaxMessageBudget(){\cf17  const override }\{ {\cf19 return} 1; \}  {\cf20 // Minimal}\par
}
\par
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Memory Monitoring} \par}
Access comprehensive memory information: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid SystemMemoryInfo info;\par
OS.getSystemMemoryInfo(info);\par
{\cf20 // info.freeRam, info.stackUsed, info.flashUsed, info.eepromUsed, etc.}\par
}
\par
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Formatted Logging} \par}
Use memory-efficient formatted logging: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid logDebugf(F({\cf22 "Value: %d, Status: %s"}), value, status);\par
logInfof(F({\cf22 "Operation %d complete"}), operation_id);\par
logWarnf(F({\cf22 "Low memory: %d bytes"}), free_memory);\par
logErrorf(F({\cf22 "Failed after %d attempts"}), attempts);\par
}
\par
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Configuration Parameters} \par}
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Stack Canary Protection} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf21 #ifndef FSMOS_STACK_CANARY_MARGIN}\par
{\cf21 #define FSMOS_STACK_CANARY_MARGIN 32  }{\cf20 // Safety margin in bytes}\par
{\cf21 #endif}\par
}
\par
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Topic Bitfield Size} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf21 #ifndef TOPIC_BITFIELD_SIZE}\par
{\cf21 #define TOPIC_BITFIELD_SIZE 16  }{\cf20 // 8, 16, or 32 topics max}\par
{\cf21 #endif}\par
}
\par
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Message Pool Size} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf21 #ifndef MAX_MESSAGE_POOL_SIZE}\par
{\cf21 #define MAX_MESSAGE_POOL_SIZE 32  }{\cf20 // Maximum messages in pool}\par
{\cf21 #endif}\par
}
\par
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Default Values} \par}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf17 const} uint8_t DEFAULT_TASK_MESSAGE_BUDGET = 1;  {\cf20 // Messages per step}\par
{\cf17 const} uint16_t DEFAULT_TASK_PERIOD = 100;       {\cf20 // Default period in ms}\par
}
\par
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Memory Optimization Features} \par}
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Stack Canary} \par}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Automatic stack overflow detection\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Configurable safety margin\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Marks entire free RAM region between heap and stack\par}
\par
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Memory Leak Detection} \par}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Tracks all memory allocations and deallocations\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Provides peak usage and current usage statistics\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Always active (no conditional compilation)\par}
\par
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 {\b Task} Limit Control} \par}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Prevents adding more tasks than {\f2 MAX_TOPICS}  allows\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Runtime logging and rejection of excess tasks\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Based on {\f2 TOPIC_BITFIELD_SIZE}  configuration\par}
\par
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Message Data Optimization} \par}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Simplified message structure (type + arg only)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No dynamic data allocation for messages\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Reduced memory footprint per message\par}
\par
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Platformio Configuration} \par}
For optimal performance with Arduino Nano, use these build flags: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid build_flags =\par
  -Os                    # Size optimization\par
  -ffunction-sections    # Function sectioning\par
  -fdata-sections       # Data sectioning\par
  -fno-exceptions       # Remove exception handling\par
  -DTOPIC_BITFIELD_SIZE=16  # Topic bitfield size\par
  -Wl,--gc-sections     # Dead code elimination\par
  -fno-lto              # Disable LTO\par
  -DNDEBUG              # Remove debug symbols\par
  -mmcu=atmega328p      # AVR architecture\par
  -fno-stack-protector  # Reduce stack usage\par
  -fpack-struct=1       # Memory alignment\par
  -DFSMOS_FLASH_SIZE=30720  # Flash size\par
  -DFSMOS_EEPROM_SIZE=1024  # EEPROM size\par
}
\par
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Memory Usage} \par}
Typical memory usage on Arduino Nano (ATmega328P):{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RAM} : ~1.3KB (64% of 2KB)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Flash} : ~29KB (95% of 30KB)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Message Pool} : 32 messages \'D7 5 bytes = 160 bytes\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Stack Canary} : 32 bytes safety margin\par}
\par
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 API Reference} \par}
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Core Functions} \par}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 OS.begin()}  - Initialize scheduler\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 OS.begin_with_logger()}  - Initialize with logging\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 OS.add(task)}  - Add task to scheduler\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 OS.loop_once()}  - Run one scheduler cycle\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 OS.getTaskCount()}  - Get current task count\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 OS.getFreeMemory()}  - Get free RAM\par}
\par
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 {\b Task} Methods} \par}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 set_period(ms)}  - Set task period\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 set_priority(level)}  - Set task priority\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 publish(topic, type, arg)}  - Publish message\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 subscribe(topic)}  - Subscribe to topic\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 logInfo(msg)}  - Log info message\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 logDebug(msg)}  - Log debug message\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 logWarn(msg)}  - Log warning message\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 logError(msg)}  - Log error message\par}
\par
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Memory Functions} \par}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 OS.getSystemMemoryInfo(info)}  - Get comprehensive memory info\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 OS.getMemoryStats()}  - Get memory allocation statistics\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 OS.getTaskStats()}  - Get task execution statistics\par}
\par
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Troubleshooting} \par}
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Common Issues} \par}
{
\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab {\b {\b Task} limit reached} : Reduce {\f2 TOPIC_BITFIELD_SIZE}  or optimize task count\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
2.\tab {\b Memory overflow} : Check stack canary warnings and reduce memory usage\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
3.\tab {\b Message queue full} : Increase {\f2 MAX_MESSAGE_POOL_SIZE}  or optimize message budgets\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
4.\tab {\b Compilation errors} : Ensure all required methods are implemented\par}
\par
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Debug Commands} \par}
Use serial commands for debugging:{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 s}  - System statistics\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 mem}  - Memory information\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 tl}  - {\b Task} limit check\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 st}  - {\b Task} status\par}
\par
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Contributing} \par}
{
\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab Fork the repository\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
2.\tab Create your feature branch\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
3.\tab Commit your changes\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
4.\tab Push to the branch\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
5.\tab Create a Pull Request\par}
\par
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 License} \par}
This project is licensed under the MIT License. See the LICENSE file for details.\par
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Changelog} \par}
{\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid {\tc\tcl1 Version 1.3.0} \par}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Removed message data system for memory optimization\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Enhanced stack canary protection\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Added task limit control\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Improved memory leak detection\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Optimized message structure (type + arg only)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Reduced memory footprint per message by 7 bytes \par}
\par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Topic Index\par \pard\plain 
{\tc \v Topic Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Topics\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all topics with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
FsmOS\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b LinkedQueue< T >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lightweight, interrupt-safe linked queue })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MemoryStats} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory tracking statistics })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MsgDataPool} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory pool for efficient MsgData allocation })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Scheduler::MsgNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Mutex} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Mutex} for cooperative task synchronization })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b LinkedQueue< T >::Node} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Node} structure for linked list })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Scheduler::QueuedMessage} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ResetInfo} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
System reset information })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Scheduler} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Core scheduler and task manager for FsmOS })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Semaphore} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Semaphore} for resource counting and synchronization })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SharedMsg} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Smart pointer-like wrapper for MsgData with reference counting })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SystemMemoryInfo} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
System memory information })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Task} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base class for all tasks in FsmOS })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TaskMemoryInfo} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} memory information })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TaskNode} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Node structure for {\b Task} linked list })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TaskStats} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} execution statistics })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b FsmOS.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementation of the FsmOS cooperative task scheduler })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b FsmOS.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A lightweight cooperative task scheduler for Arduino })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Topic Documentation{\tc \v Topic Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
FsmOS\par \pard\plain 
{\tc\tcl2 \v FsmOS}
{\xe \v FsmOS}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lightweight cooperative scheduler and message-passing library for Arduino. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TaskNode}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Node structure for {\b Task} linked list. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MemoryStats}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory tracking statistics. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TaskStats}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} execution statistics. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ResetInfo}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
System reset information. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SystemMemoryInfo}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
System memory information. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TaskMemoryInfo}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} memory information. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SharedMsg}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Smart pointer-like wrapper for MsgData with reference counting. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MsgDataPool}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory pool for efficient MsgData allocation. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b LinkedQueue< T >}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lightweight, interrupt-safe linked queue. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Mutex}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Mutex} for cooperative task synchronization. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Semaphore}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Semaphore} for resource counting and synchronization. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Scheduler}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Core scheduler and task manager for FsmOS. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOPIC_BITFIELD_SIZE}\~ 16\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Topic bitfield configuration. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RESET_CAUSE_EXTERNAL}\~ 0x01\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reset cause flag constants from MCUSR register. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ResetCause} \{ {\b RESET_UNKNOWN} = 0
, {\b RESET_POWER_ON}
, {\b RESET_EXTERNAL}
, {\b RESET_BROWN_OUT}
, {\b RESET_WATCHDOG}
, {\b RESET_MULTIPLE}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reset cause enumeration for Optiboot reset flags. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > struct {\b __attribute__} ((packed)) TimerT\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory-optimized template-based timer for specific duration ranges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __attribute__} ((packed)) MsgData\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Message data structure for inter-task communication. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual uint8_t {\b Task::getMaxMessageBudget} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the maximum number of messages this task may produce in one {\b step()} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logDebugf} (const __FlashStringHelper *format,...)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default per-task message production budget. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logInfof} (const __FlashStringHelper *format,...)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log an info message with formatting. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logWarnf} (const __FlashStringHelper *format,...)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log a warning message with formatting. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logErrorf} (const __FlashStringHelper *format,...)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log an error message with formatting. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const uint8_t {\b DEFAULT_TASK_MESSAGE_BUDGET} = 1\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base class for all tasks in FsmOS. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Scheduler} {\b OS}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Global scheduler instance. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const uint16_t {\b DEFAULT_TASK_PERIOD} = 100\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default task period in milliseconds. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const uint16_t {\b MIN_TASK_PERIOD} = 1\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minimum allowed task period in milliseconds. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const uint16_t {\b MAX_TASK_PERIOD} = 65535\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum allowed task period in milliseconds. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lightweight cooperative scheduler and message-passing library for Arduino. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Provides tasks, scheduler, message passing, synchronization primitives, and diagnostics with a focus on small RAM/flash usage and clear APIs. \par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v RESET_CAUSE_EXTERNAL\:FsmOS}
{\xe \v FsmOS\:RESET_CAUSE_EXTERNAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RESET_CAUSE_EXTERNAL\~ 0x01}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reset cause flag constants from MCUSR register. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
These flags are stored by Optiboot in GPIOR0 External Reset flag (fallback) \par
}{
Definition at line {\b 185} of file {\b FsmOS.h}.}\par
}
{\xe \v TOPIC_BITFIELD_SIZE\:FsmOS}
{\xe \v FsmOS\:TOPIC_BITFIELD_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOPIC_BITFIELD_SIZE\~ 16}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Topic bitfield configuration. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Choose the bitfield size based on your topic count:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
TOPIC_BITFIELD_8: 8 topics max (1 byte)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
TOPIC_BITFIELD_16: 16 topics max (2 bytes) - DEFAULT\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
TOPIC_BITFIELD_32: 32 topics max (4 bytes) \par}
}{
Definition at line {\b 70} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v ResetCause\:FsmOS}
{\xe \v FsmOS\:ResetCause}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b ResetCause}}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reset cause enumeration for Optiboot reset flags. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to identify the cause of system reset \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v RESET_UNKNOWN\:FsmOS}
{\xe \v FsmOS\:RESET_UNKNOWN}
{\qr RESET_UNKNOWN{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Unknown reset cause. \par
}\cell }{\row }
{\xe \v RESET_POWER_ON\:FsmOS}
{\xe \v FsmOS\:RESET_POWER_ON}
{\qr RESET_POWER_ON{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Power-on reset. \par
}\cell }{\row }
{\xe \v RESET_EXTERNAL\:FsmOS}
{\xe \v FsmOS\:RESET_EXTERNAL}
{\qr RESET_EXTERNAL{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
External reset. \par
}\cell }{\row }
{\xe \v RESET_BROWN_OUT\:FsmOS}
{\xe \v FsmOS\:RESET_BROWN_OUT}
{\qr RESET_BROWN_OUT{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brown-out reset. \par
}\cell }{\row }
{\xe \v RESET_WATCHDOG\:FsmOS}
{\xe \v FsmOS\:RESET_WATCHDOG}
{\qr RESET_WATCHDOG{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Watchdog reset. \par
}\cell }{\row }
{\xe \v RESET_MULTIPLE\:FsmOS}
{\xe \v FsmOS\:RESET_MULTIPLE}
{\qr RESET_MULTIPLE{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiple reset causes detected. \par
}\cell }{\row }
}
{
Definition at line {\b 164} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:FsmOS}
{\xe \v FsmOS\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct __attribute__ ((packed) )}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Message data structure for inter-task communication. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This structure holds the actual message data and is managed by the message pool system for efficient memory usage.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Messages are reference-counted and automatically returned to the pool when no longer needed. \par
}}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
< Message type identifier\par
< Topic/channel for message routing\par
< Additional argument data\par
< Reference count for memory management\par
}{
Definition at line {\b 78} of file {\b FsmOS.h}.}\par
}
{\xe \v __attribute__\:FsmOS}
{\xe \v FsmOS\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > struct __attribute__ ((packed) )}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory-optimized template-based timer for specific duration ranges. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i T} \cell }{The integer type to use for timing (uint8_t, uint16_t, uint32_t) Choose based on your maximum duration needs:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t: 0-255ms (2 bytes total)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t: 0-65535ms (4 bytes total)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t: 0-4294967295ms (8 bytes total)\par}
\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
This template allows memory optimization by using smaller data types for shorter timer durations, reducing RAM usage in memory-constrained systems. \par
}}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
< Timer start timestamp in milliseconds\par
< Timer duration in milliseconds\par
Start the timer with specified duration {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i d} \cell }{Duration in milliseconds \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Timer will be marked as expired if duration is 0\par
}}Check if timer has expired \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if timer duration has elapsed, false otherwise \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Handles type-specific overflow correctly\par
}}}{
Definition at line {\b 78} of file {\b FsmOS.h}.}\par
}
{\xe \v getMaxMessageBudget\:FsmOS}
{\xe \v FsmOS\:getMaxMessageBudget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual uint8_t Task::getMaxMessageBudget () const{\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the maximum number of messages this task may produce in one {\b step()} }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Scheduler} uses this to ensure there are at least this many free message slots before running the task. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Planned message production budget for the upcoming step \par
}}}{
Definition at line {\b 801} of file {\b FsmOS.h}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "group__fsmos_gadf715a30a3759bfd0856f12cfdf29d0e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v logDebugf\:FsmOS}
{\xe \v FsmOS\:logDebugf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void logDebugf (const __FlashStringHelper *  {\i format},   {\i ...})}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default per-task message production budget. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If a task does not explicitly declare a budget via {\b Task::setMaxMessageBudget}, the scheduler applies this default to ensure capacity checks are enforced.\par
Log a debug message with formatting {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i format} \cell }{Format string (FlashStringHelper) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ...} \cell }{Variable arguments for formatting \cell }
{\row }
}
}{
Definition at line {\b 1695} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "group__fsmos_gac6c8dbf1f133ab906d0f3490e0de5d74_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v logErrorf\:FsmOS}
{\xe \v FsmOS\:logErrorf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void logErrorf (const __FlashStringHelper *  {\i format},   {\i ...})}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log an error message with formatting. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i format} \cell }{Format string (FlashStringHelper) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ...} \cell }{Variable arguments for formatting \cell }
{\row }
}
}{
Definition at line {\b 1719} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "group__fsmos_gade3c130d653bf887af5b2f6120f388ad_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v logInfof\:FsmOS}
{\xe \v FsmOS\:logInfof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void logInfof (const __FlashStringHelper *  {\i format},   {\i ...})}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log an info message with formatting. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i format} \cell }{Format string (FlashStringHelper) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ...} \cell }{Variable arguments for formatting \cell }
{\row }
}
}{
Definition at line {\b 1703} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "group__fsmos_ga0fd80592a7d1d2fd9b1b52081a8d69cb_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "group__fsmos_ga0fd80592a7d1d2fd9b1b52081a8d69cb_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v logWarnf\:FsmOS}
{\xe \v FsmOS\:logWarnf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void logWarnf (const __FlashStringHelper *  {\i format},   {\i ...})}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log a warning message with formatting. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i format} \cell }{Format string (FlashStringHelper) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ...} \cell }{Variable arguments for formatting \cell }
{\row }
}
}{
Definition at line {\b 1711} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "group__fsmos_ga58264bc1f779d2cd6cb6a8c733a17a21_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v DEFAULT_TASK_MESSAGE_BUDGET\:FsmOS}
{\xe \v FsmOS\:DEFAULT_TASK_MESSAGE_BUDGET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const uint8_t DEFAULT_TASK_MESSAGE_BUDGET = 1}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base class for all tasks in FsmOS. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} provides the foundation for cooperative multitasking. Each task runs in its own context and can communicate with other tasks through messages and events.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Tasks must implement the step() method to define their behavior. The scheduler calls step() periodically based on the task's period.\par
}}Default message budget for tasks\par
If a task does not explicitly declare a budget via {\b Task::setMaxMessageBudget}, the scheduler applies this default to ensure capacity checks are enforced. \par
}{
Definition at line {\b 648} of file {\b FsmOS.h}.}\par
}
{\xe \v DEFAULT_TASK_PERIOD\:FsmOS}
{\xe \v FsmOS\:DEFAULT_TASK_PERIOD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const uint16_t DEFAULT_TASK_PERIOD = 100}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default task period in milliseconds. }}\par
{
Definition at line {\b 1515} of file {\b FsmOS.h}.}\par
}
{\xe \v MAX_TASK_PERIOD\:FsmOS}
{\xe \v FsmOS\:MAX_TASK_PERIOD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const uint16_t MAX_TASK_PERIOD = 65535}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum allowed task period in milliseconds. }}\par
{
Definition at line {\b 1527} of file {\b FsmOS.h}.}\par
}
{\xe \v MIN_TASK_PERIOD\:FsmOS}
{\xe \v FsmOS\:MIN_TASK_PERIOD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const uint16_t MIN_TASK_PERIOD = 1}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minimum allowed task period in milliseconds. }}\par
{
Definition at line {\b 1521} of file {\b FsmOS.h}.}\par
}
{\xe \v OS\:FsmOS}
{\xe \v FsmOS\:OS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Scheduler} OS{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Global scheduler instance. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Convenient global instance for easy access \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
This is the main scheduler instance used by most applications \par
}}}{
Definition at line {\b 48} of file {\b FsmOS.cpp}.}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
LinkedQueue< T > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v LinkedQueue< T >}
{\xe \v LinkedQueue< T >}
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lightweight, interrupt-safe linked queue. }}\par
{
{\f2 #include <FsmOS.h>}}\par
Collaboration diagram for LinkedQueue< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classLinkedQueue__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Node}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Node} structure for linked list. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LinkedQueue} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~LinkedQueue} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LinkedQueue} ({\b LinkedQueue} &&other) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Move constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b push} (const T &item)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add item to the end of the queue. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b pop} (T &item)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove item from the front of the queue. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isEmpty} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if queue is empty. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b getSize} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get number of items in queue. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Node} * {\b head}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to first node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Node} * {\b tail}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to last node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b count}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of items in queue. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
class LinkedQueue< T >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lightweight, interrupt-safe linked queue. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b LinkedQueue} provides a simple queue implementation that is safe to use from interrupt context. It uses a linked list structure for efficient insertion and removal.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i T} \cell }{Type of elements to store in the queue \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
This queue is not thread-safe for concurrent access \par
}}}{
Definition at line {\b 464} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v LinkedQueue\:LinkedQueue< T >}
{\xe \v LinkedQueue< T >\:LinkedQueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b LinkedQueue}< T >{\b ::LinkedQueue} ()}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates an empty queue \par
}{
Definition at line {\b 310} of file {\b FsmOS.cpp}.}\par
}
{\xe \v ~LinkedQueue\:LinkedQueue< T >}
{\xe \v LinkedQueue< T >\:~LinkedQueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b LinkedQueue}< T >::~{\b LinkedQueue} ()}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Frees all nodes in the queue \par
}{
Definition at line {\b 313} of file {\b FsmOS.cpp}.}\par
}
{\xe \v LinkedQueue\:LinkedQueue< T >}
{\xe \v LinkedQueue< T >\:LinkedQueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b LinkedQueue}< T >{\b ::LinkedQueue} ({\b LinkedQueue}< T > &&  {\i other}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Move constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i other} \cell }{Queue to move from \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Transfers ownership of nodes from other queue \par
}}}{
Definition at line {\b 324} of file {\b FsmOS.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getSize\:LinkedQueue< T >}
{\xe \v LinkedQueue< T >\:getSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > uint8_t {\b LinkedQueue}< T >::getSize () const}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get number of items in queue. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Number of items currently in queue \par
}}}{
Definition at line {\b 384} of file {\b FsmOS.cpp}.}\par
}
{\xe \v isEmpty\:LinkedQueue< T >}
{\xe \v LinkedQueue< T >\:isEmpty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool {\b LinkedQueue}< T >::isEmpty () const}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if queue is empty. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if queue is empty, false otherwise \par
}}}{
Definition at line {\b 378} of file {\b FsmOS.cpp}.}\par
}
{\xe \v pop\:LinkedQueue< T >}
{\xe \v LinkedQueue< T >\:pop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool {\b LinkedQueue}< T >::pop (T &  {\i item})}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove item from the front of the queue. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i item} \cell }{Reference to store the removed item \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if item was removed, false if queue was empty \par
}}}{
Definition at line {\b 356} of file {\b FsmOS.cpp}.}\par
}
{\xe \v push\:LinkedQueue< T >}
{\xe \v LinkedQueue< T >\:push}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void {\b LinkedQueue}< T >::push (const T &  {\i item})}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add item to the end of the queue. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i item} \cell }{Item to add \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Allocates new node for the item \par
}}}{
Definition at line {\b 332} of file {\b FsmOS.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v count\:LinkedQueue< T >}
{\xe \v LinkedQueue< T >\:count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > uint8_t {\b LinkedQueue}< T >::count{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of items in queue. }}\par
{
Definition at line {\b 524} of file {\b FsmOS.h}.}\par
}
{\xe \v head\:LinkedQueue< T >}
{\xe \v LinkedQueue< T >\:head}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Node}* {\b LinkedQueue}< T >::head{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to first node. }}\par
{
Definition at line {\b 522} of file {\b FsmOS.h}.}\par
}
{\xe \v tail\:LinkedQueue< T >}
{\xe \v LinkedQueue< T >\:tail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Node}* {\b LinkedQueue}< T >::tail{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to last node. }}\par
{
Definition at line {\b 523} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FsmOS.h}\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FsmOS.cpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MemoryStats Struct Reference\par \pard\plain 
{\tc\tcl2 \v MemoryStats}
{\xe \v MemoryStats}
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory tracking statistics. }}\par
{
{\f2 #include <FsmOS.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b total_allocated}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total bytes allocated. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b total_freed}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total bytes freed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b peak_usage}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Peak memory usage. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b current_usage}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current memory usage. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory tracking statistics. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used for memory leak detection and monitoring \par
}{
Definition at line {\b 114} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v current_usage\:MemoryStats}
{\xe \v MemoryStats\:current_usage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t MemoryStats::current_usage}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current memory usage. }}\par
{
Definition at line {\b 119} of file {\b FsmOS.h}.}\par
}
{\xe \v peak_usage\:MemoryStats}
{\xe \v MemoryStats\:peak_usage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t MemoryStats::peak_usage}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Peak memory usage. }}\par
{
Definition at line {\b 118} of file {\b FsmOS.h}.}\par
}
{\xe \v total_allocated\:MemoryStats}
{\xe \v MemoryStats\:total_allocated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t MemoryStats::total_allocated}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total bytes allocated. }}\par
{
Definition at line {\b 116} of file {\b FsmOS.h}.}\par
}
{\xe \v total_freed\:MemoryStats}
{\xe \v MemoryStats\:total_freed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t MemoryStats::total_freed}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total bytes freed. }}\par
{
Definition at line {\b 117} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FsmOS.h}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MsgDataPool Class Reference\par \pard\plain 
{\tc\tcl2 \v MsgDataPool}
{\xe \v MsgDataPool}
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory pool for efficient MsgData allocation. }}\par
{
{\f2 #include <FsmOS.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MsgDataPool} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~MsgDataPool} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MsgData} * {\b allocate} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allocate a new MsgData from the pool. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b deallocate} ({\b MsgData} *msg)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a MsgData to the pool. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b updateAdaptiveLimit} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update adaptive pool limit based on usage. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b getPoolSize} () {\b const}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get current pool size. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b getPoolLimit} () {\b const}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get maximum pool limit. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b getCurrentInUse} () {\b const}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get number of currently allocated messages. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b initialize} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the message pool if not already initialized. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MsgData} * {\b pool}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Array of MsgData objects. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b poolSize}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current pool size. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b poolLimit}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum pool size. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b currentInUse}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of messages currently in use. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b nextFree}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Index of next free message. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory pool for efficient MsgData allocation. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b MsgDataPool} manages a pool of MsgData objects to avoid frequent memory allocation/deallocation. It uses an adaptive limit system to balance memory usage and performance.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The pool automatically adjusts its size based on usage patterns. \par
}}}{
Definition at line {\b 383} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v MsgDataPool\:MsgDataPool}
{\xe \v MsgDataPool\:MsgDataPool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MsgDataPool::MsgDataPool ()}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes the message pool with default settings \par
}{
Definition at line {\b 183} of file {\b FsmOS.cpp}.}\par
}
{\xe \v ~MsgDataPool\:MsgDataPool}
{\xe \v MsgDataPool\:~MsgDataPool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MsgDataPool::~MsgDataPool ()}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Frees all allocated memory \par
}{
Definition at line {\b 190} of file {\b FsmOS.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v allocate\:MsgDataPool}
{\xe \v MsgDataPool\:allocate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MsgData} * MsgDataPool::allocate ()}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allocate a new MsgData from the pool. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Pointer to allocated MsgData, or nullptr if pool is full \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Returns nullptr if no memory available \par
}}}{
Definition at line {\b 199} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classMsgDataPool_a5249e1c96225998fac71ba67c691740d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v deallocate\:MsgDataPool}
{\xe \v MsgDataPool\:deallocate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} MsgDataPool::deallocate ({\b MsgData} *  {\i msg})}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a MsgData to the pool. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i msg} \cell }{Pointer to MsgData to deallocate \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Frees any associated data and returns MsgData to pool \par
}}}{
Definition at line {\b 236} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classMsgDataPool_a9b78a83be33a8a2a938f576eee7a98ee_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classMsgDataPool_a9b78a83be33a8a2a938f576eee7a98ee_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getCurrentInUse\:MsgDataPool}
{\xe \v MsgDataPool\:getCurrentInUse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} MsgDataPool::getCurrentInUse () const}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get number of currently allocated messages. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Number of messages currently in use \par
}}}{
Definition at line {\b 276} of file {\b FsmOS.cpp}.}\par
}
{\xe \v getPoolLimit\:MsgDataPool}
{\xe \v MsgDataPool\:getPoolLimit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} MsgDataPool::getPoolLimit () const}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get maximum pool limit. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Maximum number of MsgData objects allowed \par
}}}{
Definition at line {\b 274} of file {\b FsmOS.cpp}.}\par
}
{\xe \v getPoolSize\:MsgDataPool}
{\xe \v MsgDataPool\:getPoolSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} MsgDataPool::getPoolSize () const}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get current pool size. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Current number of MsgData objects in pool \par
}}}{
Definition at line {\b 272} of file {\b FsmOS.cpp}.}\par
}
{\xe \v initialize\:MsgDataPool}
{\xe \v MsgDataPool\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} MsgDataPool::initialize ()}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the message pool if not already initialized. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if pool was initialized successfully, false if already initialized or failed \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
This method performs lazy initialization to avoid static allocation issues \par
}}}{
Definition at line {\b 278} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classMsgDataPool_aed7f37c999de507b0441f863a4942f2a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classMsgDataPool_aed7f37c999de507b0441f863a4942f2a_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v updateAdaptiveLimit\:MsgDataPool}
{\xe \v MsgDataPool\:updateAdaptiveLimit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} MsgDataPool::updateAdaptiveLimit ()}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update adaptive pool limit based on usage. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Automatically adjusts pool size for optimal performance \par
}{
Definition at line {\b 258} of file {\b FsmOS.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classMsgDataPool_aec9292e845c522cd14c90764b8bfc054_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v currentInUse\:MsgDataPool}
{\xe \v MsgDataPool\:currentInUse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t MsgDataPool::currentInUse{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of messages currently in use. }}\par
{
Definition at line {\b 447} of file {\b FsmOS.h}.}\par
}
{\xe \v nextFree\:MsgDataPool}
{\xe \v MsgDataPool\:nextFree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} MsgDataPool::nextFree{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Index of next free message. }}\par
{
Definition at line {\b 448} of file {\b FsmOS.h}.}\par
}
{\xe \v pool\:MsgDataPool}
{\xe \v MsgDataPool\:pool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MsgData}* MsgDataPool::pool{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Array of MsgData objects. }}\par
{
Definition at line {\b 444} of file {\b FsmOS.h}.}\par
}
{\xe \v poolLimit\:MsgDataPool}
{\xe \v MsgDataPool\:poolLimit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} MsgDataPool::poolLimit{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum pool size. }}\par
{
Definition at line {\b 446} of file {\b FsmOS.h}.}\par
}
{\xe \v poolSize\:MsgDataPool}
{\xe \v MsgDataPool\:poolSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} MsgDataPool::poolSize{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current pool size. }}\par
{
Definition at line {\b 445} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FsmOS.h}\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FsmOS.cpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Scheduler::MsgNode Struct Reference\par \pard\plain 
{\tc\tcl2 \v Scheduler::MsgNode}
{\xe \v Scheduler::MsgNode}
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
Collaboration diagram for Scheduler::MsgNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structScheduler_1_1MsgNode__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MsgNode} * {\b next}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QueuedMessage} {\b payload}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 1464} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v next\:Scheduler::MsgNode}
{\xe \v Scheduler::MsgNode\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MsgNode}* Scheduler::MsgNode::next}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1466} of file {\b FsmOS.h}.}\par
}
{\xe \v payload\:Scheduler::MsgNode}
{\xe \v Scheduler::MsgNode\:payload}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QueuedMessage} Scheduler::MsgNode::payload}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1467} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FsmOS.h}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Mutex Class Reference\par \pard\plain 
{\tc\tcl2 \v Mutex}
{\xe \v Mutex}
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Mutex} for cooperative task synchronization. }}\par
{
{\f2 #include <FsmOS.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Mutex} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b tryLock} (uint8_t task_id)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Try to acquire the mutex. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b unlock} (uint8_t task_id)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Release the mutex. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isLocked} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if mutex is currently locked. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b getOwner} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get ID of task that owns the mutex. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile bool {\b locked}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lock state. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile uint8_t {\b owner_id}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ID of owning task. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Mutex} for cooperative task synchronization. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Mutex} provides mutual exclusion for shared resources in a cooperative multitasking environment. Only one task can hold the mutex at a time.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
This mutex is designed for cooperative multitasking only. It does not provide blocking behavior - tasks must check try_lock() and yield if the mutex is not available. \par
}}}{
Definition at line {\b 540} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Mutex\:Mutex}
{\xe \v Mutex\:Mutex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Mutex::Mutex ()}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates an unlocked mutex \par
}{
Definition at line {\b 393} of file {\b FsmOS.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getOwner\:Mutex}
{\xe \v Mutex\:getOwner}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Mutex::getOwner () const}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get ID of task that owns the mutex. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b Task} ID of owner, or 0 if unlocked \par
}}}{
Definition at line {\b 423} of file {\b FsmOS.cpp}.}\par
}
{\xe \v isLocked\:Mutex}
{\xe \v Mutex\:isLocked}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Mutex::isLocked () const}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if mutex is currently locked. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if locked, false if available \par
}}}{
Definition at line {\b 421} of file {\b FsmOS.cpp}.}\par
}
{\xe \v tryLock\:Mutex}
{\xe \v Mutex\:tryLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Mutex::tryLock (uint8_t  {\i task_id})}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Try to acquire the mutex. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i task_id} \cell }{ID of the task attempting to acquire the mutex \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if mutex was acquired, false if already locked \par
}}}{
Definition at line {\b 395} of file {\b FsmOS.cpp}.}\par
}
{\xe \v unlock\:Mutex}
{\xe \v Mutex\:unlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Mutex::unlock (uint8_t  {\i task_id})}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Release the mutex. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i task_id} \cell }{ID of the task releasing the mutex \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Only the task that acquired the mutex can release it \par
}}}{
Definition at line {\b 409} of file {\b FsmOS.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v locked\:Mutex}
{\xe \v Mutex\:locked}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile bool Mutex::locked{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lock state. }}\par
{
Definition at line {\b 576} of file {\b FsmOS.h}.}\par
}
{\xe \v owner_id\:Mutex}
{\xe \v Mutex\:owner_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile uint8_t Mutex::owner_id{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ID of owning task. }}\par
{
Definition at line {\b 577} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FsmOS.h}\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FsmOS.cpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
LinkedQueue< T >::Node Struct Reference\par \pard\plain 
{\tc\tcl2 \v LinkedQueue< T >::Node}
{\xe \v LinkedQueue< T >::Node}
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Node} structure for linked list. }}\par
{
{\f2 #include <FsmOS.h>}}\par
Collaboration diagram for LinkedQueue< T >::Node:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structLinkedQueue_1_1Node__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b data}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Data stored in the node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Node} * {\b next}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to next node. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct LinkedQueue< T >::Node\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Node} structure for linked list. \par
}{
Definition at line {\b 470} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v data\:LinkedQueue< T >::Node}
{\xe \v LinkedQueue< T >::Node\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T {\b LinkedQueue}< T >::Node::data}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Data stored in the node. }}\par
{
Definition at line {\b 472} of file {\b FsmOS.h}.}\par
}
{\xe \v next\:LinkedQueue< T >::Node}
{\xe \v LinkedQueue< T >::Node\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Node}* {\b LinkedQueue}< T >::Node::next}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to next node. }}\par
{
Definition at line {\b 473} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FsmOS.h}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Scheduler::QueuedMessage Struct Reference\par \pard\plain 
{\tc\tcl2 \v Scheduler::QueuedMessage}
{\xe \v Scheduler::QueuedMessage}
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b targetTaskId}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
MsgData {\b msg}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t * {\b buffer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b capacity}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 1455} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v buffer\:Scheduler::QueuedMessage}
{\xe \v Scheduler::QueuedMessage\:buffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t* Scheduler::QueuedMessage::buffer}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1459} of file {\b FsmOS.h}.}\par
}
{\xe \v capacity\:Scheduler::QueuedMessage}
{\xe \v Scheduler::QueuedMessage\:capacity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Scheduler::QueuedMessage::capacity}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1460} of file {\b FsmOS.h}.}\par
}
{\xe \v msg\:Scheduler::QueuedMessage}
{\xe \v Scheduler::QueuedMessage\:msg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MsgData Scheduler::QueuedMessage::msg}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1458} of file {\b FsmOS.h}.}\par
}
{\xe \v targetTaskId\:Scheduler::QueuedMessage}
{\xe \v Scheduler::QueuedMessage\:targetTaskId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Scheduler::QueuedMessage::targetTaskId}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1457} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FsmOS.h}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ResetInfo Struct Reference\par \pard\plain 
{\tc\tcl2 \v ResetInfo}
{\xe \v ResetInfo}
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
System reset information. }}\par
{
{\f2 #include <FsmOS.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b resetReason}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reason for reset. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b resetTime}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Time of reset. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b watchdogTimeout}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Watchdog timeout value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b lastTaskId}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ID of last running task. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b optibootResetFlags}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Raw reset flags from Optiboot GPIOR0. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b optibootResetCause}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processed reset cause (ResetCause enum) }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
System reset information. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used for debugging system resets and crashes \par
}{
Definition at line {\b 147} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v lastTaskId\:ResetInfo}
{\xe \v ResetInfo\:lastTaskId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t ResetInfo::lastTaskId}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ID of last running task. }}\par
{
Definition at line {\b 152} of file {\b FsmOS.h}.}\par
}
{\xe \v optibootResetCause\:ResetInfo}
{\xe \v ResetInfo\:optibootResetCause}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t ResetInfo::optibootResetCause}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processed reset cause (ResetCause enum) }}\par
{
Definition at line {\b 156} of file {\b FsmOS.h}.}\par
}
{\xe \v optibootResetFlags\:ResetInfo}
{\xe \v ResetInfo\:optibootResetFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t ResetInfo::optibootResetFlags}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Raw reset flags from Optiboot GPIOR0. }}\par
{
Definition at line {\b 155} of file {\b FsmOS.h}.}\par
}
{\xe \v resetReason\:ResetInfo}
{\xe \v ResetInfo\:resetReason}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t ResetInfo::resetReason}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reason for reset. }}\par
{
Definition at line {\b 149} of file {\b FsmOS.h}.}\par
}
{\xe \v resetTime\:ResetInfo}
{\xe \v ResetInfo\:resetTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ResetInfo::resetTime}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Time of reset. }}\par
{
Definition at line {\b 150} of file {\b FsmOS.h}.}\par
}
{\xe \v watchdogTimeout\:ResetInfo}
{\xe \v ResetInfo\:watchdogTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t ResetInfo::watchdogTimeout}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Watchdog timeout value. }}\par
{
Definition at line {\b 151} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FsmOS.h}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Scheduler Class Reference\par \pard\plain 
{\tc\tcl2 \v Scheduler}
{\xe \v Scheduler}
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Core scheduler and task manager for FsmOS. }}\par
{
{\f2 #include <FsmOS.h>}}\par
Collaboration diagram for Scheduler:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MsgNode}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b QueuedMessage}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b LogLevel} \{ {\b LOG_DEBUG} = 0
, {\b LOG_INFO} = 1
, {\b LOG_WARN} = 2
, {\b LOG_ERROR} = 3
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log level enumeration. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Scheduler} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Scheduler} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b add} ({\b Task} *task)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a task to the scheduler. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b remove} ({\b Task} *task)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove a task from the scheduler. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeAll} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove all tasks from the scheduler. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Task} * {\b getTask} (uint8_t task_id)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get task by ID. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b getTaskCount} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get number of active tasks. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b getMaxTasks} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get maximum number of tasks. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b begin} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start the scheduler. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b loopOnce} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Execute one scheduling step. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b loop} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run scheduler continuously. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b stop} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stop the scheduler. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b publishMessage} (uint8_t topic, uint8_t type, uint16_t arg=0)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Publish a message to a topic. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sendMessage} (uint8_t task_id, uint8_t type, uint16_t arg=0)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Send a direct message to a specific task. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b getFreeQueueSlots} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get number of free slots in the global message queue. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b now} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get current system time. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b getFreeMemory} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get amount of free memory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLogLevel} ({\b LogLevel} level)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set minimum log level. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logMessage} ({\b Task} *task, {\b LogLevel} level, const char *msg)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log a message. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logMessage} ({\b Task} *task, {\b LogLevel} level, const __FlashStringHelper *msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b onTick} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle system tick. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getResetInfo} ({\b ResetInfo} &info)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get system reset information. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResetCause} {\b getResetCause} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get reset cause from system. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b getResetCauseFlags} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get raw reset flags from system. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b wasResetCause} ({\b ResetCause} cause)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if a specific reset cause occurred. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getTaskStats} (uint8_t task_id, {\b TaskStats} &stats)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get task statistics. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getSystemMemoryInfo} ({\b SystemMemoryInfo} &info)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get system memory information. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getTaskMemoryInfo} (uint8_t task_id, {\b TaskMemoryInfo} &info)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get task memory information. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b getHeapFragmentation} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get heap fragmentation percentage. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getMemoryLeakStats} ({\b MemoryStats} &stats)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get memory leak detection statistics. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b enableWatchdog} (uint8_t timeout)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable hardware watchdog timer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b feedWatchdog} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logFormatted} ({\b Task} *task, {\b LogLevel} level, const __FlashStringHelper *format,...)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log a formatted message. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b getMostDelayingTask} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get task that caused the most delays. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b processMessages} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process pending messages for all tasks. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateSystemTime} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update system time. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Task} * {\b findNextTask} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Find next task to execute. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b executeTask} ({\b Task} *task)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Execute a task. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleTaskTiming} ({\b Task} *task, uint32_t currentTime)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle task timing monitoring. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b executeTaskStep} ({\b Task} *task)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Execute the actual task step. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateTaskStatistics} ({\b Task} *task, uint32_t execStart)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update task execution statistics. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateTimingVariables} ({\b Task} *task)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update timing monitoring variables. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b checkForTerminatedTask} ({\b Task} *task)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if task should be terminated and remove if needed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logTaskDelay} ({\b Task} *task, uint16_t delayMs, uint8_t causingTaskId)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log task delay with attribution. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Func > void {\b forEachTask} (Func func)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Iterate through all tasks with a function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Func > {\b Task} * {\b findTask} (Func predicate)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Find a task using a predicate function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TaskNode} * {\b allocateTaskNode} ({\b Task} *task)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allocate a {\b TaskNode} from the pool. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b deallocateTaskNode} ({\b TaskNode} *node)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deallocate a {\b TaskNode} back to the pool. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logSystemEvent} ({\b LogLevel} level, const __FlashStringHelper *msg)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log a system event message. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logTaskExecution} ({\b Task} *task, uint32_t execTime)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log a task execution event. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b allocateMsgNodesChunk} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b enqueueQueuedMessage} (uint8_t targetTaskId, uint8_t topic, uint8_t type, uint16_t arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b dequeueQueuedMessage} ({\b QueuedMessage} &out)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b dequeueQueuedMessageNode} ({\b MsgNode} *&outNode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b initializeTaskNodePool} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TaskNode} * {\b acquireTaskNode} ({\b Task} *task)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b releaseTaskNode} ({\b TaskNode} *node)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MsgNode} * {\b allocateMsgNode} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b deallocateMsgNode} ({\b MsgNode} *node)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TaskNode} * {\b taskHead} = nullptr\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Head of task linked list. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TaskNode} * {\b taskTail} = nullptr\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tail of task linked list. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TaskNode} * {\b freeTaskNodeHead} = nullptr\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Head of free-list for {\b TaskNode} pool. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b taskNodePoolInitialized} = false\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether pool has been initialized. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b taskNodePoolCapacity} = 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total nodes currently allocated to pool/list. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b taskCount} = 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current number of tasks. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b nextTaskId} = 1\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Next available task ID. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MsgDataPool} {\b msgPool}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Message pool for efficient allocation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b systemTime}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current system time. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b running}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Scheduler} running state. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LogLevel} {\b currentLogLevel}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current minimum log level. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b lastExecutedTaskId} = 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ID of last executed task (for delay attribution) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b lastTaskEndTime} = 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When the last task finished execution. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MsgNode} * {\b msgHead} = nullptr\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MsgNode} * {\b msgTail} = nullptr\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MsgNode} * {\b freeHead} = nullptr\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b msgCount} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b totalNodes} = 0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SharedMsg}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allow {\b SharedMsg} to access msgPool. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Core scheduler and task manager for FsmOS. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Scheduler} manages the execution of tasks, message routing, and system resources. It provides the main interface for task management and system control.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Only one scheduler instance should exist per application. The global OS instance is provided for convenience.\par
}}Core scheduler and task manager for FsmOS \par
}{
Definition at line {\b 1073} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v LogLevel\:Scheduler}
{\xe \v Scheduler\:LogLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Scheduler::LogLevel}}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log level enumeration. }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v LOG_DEBUG\:Scheduler}
{\xe \v Scheduler\:LOG_DEBUG}
{\qr LOG_DEBUG{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Debug level messages. \par
}\cell }{\row }
{\xe \v LOG_INFO\:Scheduler}
{\xe \v Scheduler\:LOG_INFO}
{\qr LOG_INFO{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Info level messages. \par
}\cell }{\row }
{\xe \v LOG_WARN\:Scheduler}
{\xe \v Scheduler\:LOG_WARN}
{\qr LOG_WARN{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Warning level messages. \par
}\cell }{\row }
{\xe \v LOG_ERROR\:Scheduler}
{\xe \v Scheduler\:LOG_ERROR}
{\qr LOG_ERROR{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Error level messages. \par
}\cell }{\row }
}
{
Definition at line {\b 1195} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Scheduler\:Scheduler}
{\xe \v Scheduler\:Scheduler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Scheduler::Scheduler ()}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes scheduler with default settings \par
}{
Definition at line {\b 620} of file {\b FsmOS.cpp}.}\par
}
{\xe \v ~Scheduler\:Scheduler}
{\xe \v Scheduler\:~Scheduler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Scheduler::~Scheduler ()}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all tasks and cleans up resources \par
}{
Definition at line {\b 707} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_afc8187779b46f64039d3ffa58f0dbe51_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v acquireTaskNode\:Scheduler}
{\xe \v Scheduler\:acquireTaskNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TaskNode} * Scheduler::acquireTaskNode ({\b Task} *  {\i task}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 710} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_afa07db3c7014412af426ee1c304ebc4b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v add\:Scheduler}
{\xe \v Scheduler\:add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Scheduler::add ({\b Task} *  {\i task})}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a task to the scheduler. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i task} \cell }{Pointer to task to add \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if task was added successfully, false if scheduler is full \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b Task} starts in INACTIVE state \par
}}}{
Definition at line {\b 783} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a278e9940ce3dd1c708c5bd55b0e4059b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v allocateMsgNode\:Scheduler}
{\xe \v Scheduler\:allocateMsgNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Scheduler::MsgNode} * Scheduler::allocateMsgNode (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1365} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a45b70d5aed26ed5bf7c4d99d9df12966_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v allocateMsgNodesChunk\:Scheduler}
{\xe \v Scheduler\:allocateMsgNodesChunk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Scheduler::allocateMsgNodesChunk (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1773} of file {\b FsmOS.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_ad767f69dc7aab8c8bd0f15720693d1c2_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v allocateTaskNode\:Scheduler}
{\xe \v Scheduler\:allocateTaskNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TaskNode} * Scheduler::allocateTaskNode ({\b Task} *  {\i task}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allocate a {\b TaskNode} from the pool. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i task} \cell }{{\b Task} to wrap in the node \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Pointer to allocated {\b TaskNode}, or nullptr if failed \par
}}}{
Definition at line {\b 1328} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a38cf4a79d14bd68514a26946b19d3d53_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a38cf4a79d14bd68514a26946b19d3d53_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v begin\:Scheduler}
{\xe \v Scheduler\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Scheduler::begin ()}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start the scheduler. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Starts all tasks and begins scheduling \par
}{
Definition at line {\b 894} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_ae552f70c9bc8fa9f7406e482d6a3769b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v checkForTerminatedTask\:Scheduler}
{\xe \v Scheduler\:checkForTerminatedTask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Scheduler::checkForTerminatedTask ({\b Task} *  {\i task}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if task should be terminated and remove if needed. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i task} \cell }{{\b Task} to check \cell }
{\row }
}
}{
Definition at line {\b 1277} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_af423092ed6af17160b11a8fab79c2eab_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_af423092ed6af17160b11a8fab79c2eab_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v deallocateMsgNode\:Scheduler}
{\xe \v Scheduler\:deallocateMsgNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Scheduler::deallocateMsgNode ({\b Scheduler::MsgNode} *  {\i node}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1381} of file {\b FsmOS.cpp}.}\par
}
{\xe \v deallocateTaskNode\:Scheduler}
{\xe \v Scheduler\:deallocateTaskNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Scheduler::deallocateTaskNode ({\b TaskNode} *  {\i node}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deallocate a {\b TaskNode} back to the pool. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i node} \cell }{{\b TaskNode} to deallocate \cell }
{\row }
}
}{
Definition at line {\b 1354} of file {\b FsmOS.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a419ac926b5685ea804fe7eae086066e3_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v dequeueQueuedMessage\:Scheduler}
{\xe \v Scheduler\:dequeueQueuedMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Scheduler::dequeueQueuedMessage ({\b QueuedMessage} &  {\i out}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1846} of file {\b FsmOS.cpp}.}\par
}
{\xe \v dequeueQueuedMessageNode\:Scheduler}
{\xe \v Scheduler\:dequeueQueuedMessageNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Scheduler::dequeueQueuedMessageNode ({\b MsgNode} *&  {\i outNode}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 720} of file {\b FsmOS.cpp}.}\par
}
{\xe \v enableWatchdog\:Scheduler}
{\xe \v Scheduler\:enableWatchdog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Scheduler::enableWatchdog (uint8_t  {\i timeout})}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable hardware watchdog timer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i timeout} \cell }{Watchdog timeout value \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
AVR-specific feature \par
}}}{
Definition at line {\b 1729} of file {\b FsmOS.cpp}.}\par
}
{\xe \v enqueueQueuedMessage\:Scheduler}
{\xe \v Scheduler\:enqueueQueuedMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Scheduler::enqueueQueuedMessage (uint8_t  {\i targetTaskId}, uint8_t  {\i topic}, uint8_t  {\i type}, uint16_t  {\i arg}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1806} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_acb1eb89034fcb709b8769ff9060063e5_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_acb1eb89034fcb709b8769ff9060063e5_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v executeTask\:Scheduler}
{\xe \v Scheduler\:executeTask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Scheduler::executeTask ({\b Task} *  {\i task}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Execute a task. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i task} \cell }{{\b Task} to execute\cell }
{\row }
}
Updates task timing and calls task->step() \par
}{
Definition at line {\b 1161} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a42e220f60192016791fa56855fcc8e46_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a42e220f60192016791fa56855fcc8e46_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v executeTaskStep\:Scheduler}
{\xe \v Scheduler\:executeTaskStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Scheduler::executeTaskStep ({\b Task} *  {\i task}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Execute the actual task step. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i task} \cell }{{\b Task} to execute \cell }
{\row }
}
}{
Definition at line {\b 1212} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a74551b047dfdd1675e53de6d1fc53ac7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a74551b047dfdd1675e53de6d1fc53ac7_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v feedWatchdog\:Scheduler}
{\xe \v Scheduler\:feedWatchdog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Scheduler::feedWatchdog ()}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1736} of file {\b FsmOS.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_aa541036ba6db4765a2270d39f74c8758_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v findNextTask\:Scheduler}
{\xe \v Scheduler\:findNextTask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Task} * Scheduler::findNextTask (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Find next task to execute. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Pointer to next task to execute, or nullptr if none ready \par
}}}{
Definition at line {\b 1109} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_aafdaee288f465a178ef154e1fce57cf4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_aafdaee288f465a178ef154e1fce57cf4_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v findTask\:Scheduler}
{\xe \v Scheduler\:findTask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Func > template {\b Task} * Scheduler::findTask< bool(*)({\b Task} *)> (Func  {\i predicate}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Find a task using a predicate function. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Func} \cell }{Function type that takes Task* and returns bool \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i predicate} \cell }{Function that returns true for the desired task \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Pointer to found task, or nullptr if not found \par
}}}{
Definition at line {\b 1309} of file {\b FsmOS.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_ad2b77c7b7e929aad03ce0034f992d876_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v forEachTask\:Scheduler}
{\xe \v Scheduler\:forEachTask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Func > template void Scheduler::forEachTask< void(*)({\b Task} *)> (Func  {\i func}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Iterate through all tasks with a function. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Func} \cell }{Function type that takes Task* parameter \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i func} \cell }{Function to call for each task \cell }
{\row }
}
}{
Definition at line {\b 1295} of file {\b FsmOS.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a3c9f6290c6ae7231b96c9ba6da36382b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getFreeMemory\:Scheduler}
{\xe \v Scheduler\:getFreeMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t Scheduler::getFreeMemory () const}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get amount of free memory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Free memory in bytes \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
AVR-specific implementation \par
}}}{
Definition at line {\b 990} of file {\b FsmOS.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a56c3c1a776927eeb7917e7b636a2e3ab_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getFreeQueueSlots\:Scheduler}
{\xe \v Scheduler\:getFreeQueueSlots}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Scheduler::getFreeQueueSlots () const}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get number of free slots in the global message queue. }}\par
{
Definition at line {\b 1749} of file {\b FsmOS.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a86ddccd30b5b2af61d3cb76d53ca1b4b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getHeapFragmentation\:Scheduler}
{\xe \v Scheduler\:getHeapFragmentation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Scheduler::getHeapFragmentation ()}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get heap fragmentation percentage. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Heap fragmentation as percentage (0-100) \par
}}}{
Definition at line {\b 1644} of file {\b FsmOS.cpp}.}\par
}
{\xe \v getMaxTasks\:Scheduler}
{\xe \v Scheduler\:getMaxTasks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t Scheduler::getMaxTasks () const}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get maximum number of tasks. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Maximum number of tasks supported \par
}}}{
Definition at line {\b 892} of file {\b FsmOS.cpp}.}\par
}
{\xe \v getMemoryLeakStats\:Scheduler}
{\xe \v Scheduler\:getMemoryLeakStats}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Scheduler::getMemoryLeakStats ({\b MemoryStats} &  {\i stats})}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get memory leak detection statistics. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i stats} \cell }{Reference to store memory leak statistics \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if stats were retrieved successfully \par
}}}{
Definition at line {\b 1649} of file {\b FsmOS.cpp}.}\par
}
{\xe \v getMostDelayingTask\:Scheduler}
{\xe \v Scheduler\:getMostDelayingTask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Scheduler::getMostDelayingTask () const}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get task that caused the most delays. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b Task} ID of the task causing most delays, or 0 if none \par
}}}{
Definition at line {\b 1754} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a2ccde4ea0d8e9a6996c4a897aee709e9_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getResetCause\:Scheduler}
{\xe \v Scheduler\:getResetCause}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ResetCause} Scheduler::getResetCause ()}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get reset cause from system. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
ResetCause enumeration value \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Combines Optiboot and other reset sources \par
}}}{
Definition at line {\b 1437} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a3d51992ab99d1b8e7055ac1b5b6445ea_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a3d51992ab99d1b8e7055ac1b5b6445ea_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getResetCauseFlags\:Scheduler}
{\xe \v Scheduler\:getResetCauseFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Scheduler::getResetCauseFlags ()}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get raw reset flags from system. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Raw reset flags byte \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Internal method for reset cause processing \par
}}}{
Definition at line {\b 1491} of file {\b FsmOS.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a06438be1e9b5f2e9441b9c8c7c0d696e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getResetInfo\:Scheduler}
{\xe \v Scheduler\:getResetInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Scheduler::getResetInfo ({\b ResetInfo} &  {\i info})}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get system reset information. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i info} \cell }{Reference to store reset information \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if reset info was retrieved successfully \par
}}}{
Definition at line {\b 1422} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_acd30d51a85bda0b42d8ee5253a42e9f4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getSystemMemoryInfo\:Scheduler}
{\xe \v Scheduler\:getSystemMemoryInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Scheduler::getSystemMemoryInfo ({\b SystemMemoryInfo} &  {\i info})}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get system memory information. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i info} \cell }{Reference to store memory information \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if memory info was retrieved successfully \par
}}}{
Definition at line {\b 1524} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a7c61b8b908a19416283e66c0fb076a40_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getTask\:Scheduler}
{\xe \v Scheduler\:getTask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Task} * Scheduler::getTask (uint8_t  {\i task_id})}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get task by ID. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i task_id} \cell }{ID of task to find \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Pointer to task, or nullptr if not found \par
}}}{
Definition at line {\b 885} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_aabf3840938cc797555cdee88f5d19dd2_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_aabf3840938cc797555cdee88f5d19dd2_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getTaskCount\:Scheduler}
{\xe \v Scheduler\:getTaskCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Scheduler::getTaskCount () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get number of active tasks. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Number of tasks currently in scheduler \par
}}}{
Definition at line {\b 1121} of file {\b FsmOS.h}.}\par
}
{\xe \v getTaskMemoryInfo\:Scheduler}
{\xe \v Scheduler\:getTaskMemoryInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Scheduler::getTaskMemoryInfo (uint8_t  {\i task_id}, {\b TaskMemoryInfo} &  {\i info})}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get task memory information. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i task_id} \cell }{ID of task to get memory info for \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i info} \cell }{Reference to store task memory information \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if memory info was retrieved successfully \par
}}}{
Definition at line {\b 1627} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a7170da5c7dfd33bd0a5bd6509538d84f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getTaskStats\:Scheduler}
{\xe \v Scheduler\:getTaskStats}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Scheduler::getTaskStats (uint8_t  {\i task_id}, {\b TaskStats} &  {\i stats})}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get task statistics. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i task_id} \cell }{ID of task to get stats for \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i stats} \cell }{Reference to store task statistics \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if stats were retrieved successfully \par
}}}{
Definition at line {\b 1502} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a4a491d929e3bee5c1bb5db4ad9a13dc3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v handleTaskTiming\:Scheduler}
{\xe \v Scheduler\:handleTaskTiming}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Scheduler::handleTaskTiming ({\b Task} *  {\i task}, uint32_t  {\i currentTime}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle task timing monitoring. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i task} \cell }{{\b Task} to monitor \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i currentTime} \cell }{Current system time \cell }
{\row }
}
}{
Definition at line {\b 1188} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a22a32d58cf6898fff48880c5349c115f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a22a32d58cf6898fff48880c5349c115f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v initializeTaskNodePool\:Scheduler}
{\xe \v Scheduler\:initializeTaskNodePool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Scheduler::initializeTaskNodePool (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 742} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_aaa8cc86207802e4a457202396b2f7441_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_aaa8cc86207802e4a457202396b2f7441_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v logFormatted\:Scheduler}
{\xe \v Scheduler\:logFormatted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Scheduler::logFormatted ({\b Task} *  {\i task}, {\b LogLevel}  {\i level}, const __FlashStringHelper *  {\i format},   {\i ...})}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log a formatted message. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i task} \cell }{{\b Task} that generated the message (can be nullptr) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i level} \cell }{Log level \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i format} \cell }{Format string (FlashStringHelper) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ...} \cell }{Variable arguments for formatting \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Simplified implementation - just logs the format string \par
}}}{
Definition at line {\b 1743} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a1ded1b3c0e167dde6574bc8b4a0aca63_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v logMessage\:Scheduler}
{\xe \v Scheduler\:logMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Scheduler::logMessage ({\b Task} *  {\i task}, {\b LogLevel}  {\i level}, const __FlashStringHelper *  {\i msg})}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1038} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_af5334fe39dbfc2286e91ee358087d3b5_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v logMessage\:Scheduler}
{\xe \v Scheduler\:logMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Scheduler::logMessage ({\b Task} *  {\i task}, {\b LogLevel}  {\i level}, const char *  {\i msg})}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log a message. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i task} \cell }{{\b Task} that generated the message (can be nullptr) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i level} \cell }{Log level \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i msg} \cell }{Message to log \cell }
{\row }
}
}{
Definition at line {\b 1001} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_acaab28b4949d5a175212d134c04cf406_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_acaab28b4949d5a175212d134c04cf406_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v logSystemEvent\:Scheduler}
{\xe \v Scheduler\:logSystemEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Scheduler::logSystemEvent ({\b LogLevel}  {\i level}, const __FlashStringHelper *  {\i msg}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log a system event message. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i level} \cell }{Log level \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i msg} \cell }{Message to log \cell }
{\row }
}
}{
Definition at line {\b 1409} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a1c6dd608a209d55e1925a4dbf5fb4344_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a1c6dd608a209d55e1925a4dbf5fb4344_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v logTaskDelay\:Scheduler}
{\xe \v Scheduler\:logTaskDelay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Scheduler::logTaskDelay ({\b Task} *  {\i task}, uint16_t  {\i delayMs}, uint8_t  {\i causingTaskId}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log task delay with attribution. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i task} \cell }{Delayed task \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i delayMs} \cell }{Delay amount in milliseconds \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i causingTaskId} \cell }{ID of task that caused the delay \cell }
{\row }
}
}{
Definition at line {\b 1285} of file {\b FsmOS.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a40371a166759f310c2223ef082526829_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v logTaskExecution\:Scheduler}
{\xe \v Scheduler\:logTaskExecution}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Scheduler::logTaskExecution ({\b Task} *  {\i task}, uint32_t  {\i execTime}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log a task execution event. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i task} \cell }{{\b Task} that was executed \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i execTime} \cell }{Execution time in microseconds \cell }
{\row }
}
}{
Definition at line {\b 1414} of file {\b FsmOS.cpp}.}\par
}
{\xe \v loop\:Scheduler}
{\xe \v Scheduler\:loop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Scheduler::loop ()}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run scheduler continuously. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Runs scheduler until {\b stop()} is called \par
}{
Definition at line {\b 955} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a81607abe2905dee2e7cf9222a9e35b8f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v loopOnce\:Scheduler}
{\xe \v Scheduler\:loopOnce}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Scheduler::loopOnce ()}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Execute one scheduling step. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Processes messages and executes one ready task \par
}{
Definition at line {\b 924} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_ae3fa321ea81e2c07e361147f4f0d606e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_ae3fa321ea81e2c07e361147f4f0d606e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v now\:Scheduler}
{\xe \v Scheduler\:now}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Scheduler::now () const}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get current system time. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Current time in milliseconds \par
}}}{
Definition at line {\b 988} of file {\b FsmOS.cpp}.}\par
}
{\xe \v onTick\:Scheduler}
{\xe \v Scheduler\:onTick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Scheduler::onTick ()}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle system tick. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called by system timer interrupt \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Updates internal system time \par
}}}{
Definition at line {\b 1075} of file {\b FsmOS.cpp}.}\par
}
{\xe \v processMessages\:Scheduler}
{\xe \v Scheduler\:processMessages}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Scheduler::processMessages (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process pending messages for all tasks. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Internal method called by step() \par
}{
Definition at line {\b 1077} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_aef20dca5b8efdd71b4e91f91d5e0240f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_aef20dca5b8efdd71b4e91f91d5e0240f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v publishMessage\:Scheduler}
{\xe \v Scheduler\:publishMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Scheduler::publishMessage (uint8_t  {\i topic}, uint8_t  {\i type}, uint16_t  {\i arg} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Publish a message to a topic. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i topic} \cell }{Topic ID to publish to \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type} \cell }{Message type \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i arg} \cell }{Additional argument data \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
All tasks subscribed to the topic will receive this message \par
}}}{
Definition at line {\b 965} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a6212cb4fdc7a3ed5c9e50e97729cff8d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a6212cb4fdc7a3ed5c9e50e97729cff8d_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v releaseTaskNode\:Scheduler}
{\xe \v Scheduler\:releaseTaskNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Scheduler::releaseTaskNode ({\b TaskNode} *  {\i node}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 715} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a2e5c9f7ad69391854d3a0dc2dd73f8b4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v remove\:Scheduler}
{\xe \v Scheduler\:remove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Scheduler::remove ({\b Task} *  {\i task})}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove a task from the scheduler. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i task} \cell }{Pointer to task to remove \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if task was removed, false if not found \par
}}}{
Definition at line {\b 829} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a303a5bd8d44b55803e6da7b4108401c2_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a303a5bd8d44b55803e6da7b4108401c2_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v removeAll\:Scheduler}
{\xe \v Scheduler\:removeAll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Scheduler::removeAll ()}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove all tasks from the scheduler. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stops and removes all tasks \par
}{
Definition at line {\b 871} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_aaa234e0155e99b4fcbae695898663eea_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_aaa234e0155e99b4fcbae695898663eea_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v sendMessage\:Scheduler}
{\xe \v Scheduler\:sendMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Scheduler::sendMessage (uint8_t  {\i task_id}, uint8_t  {\i type}, uint16_t  {\i arg} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Send a direct message to a specific task. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i task_id} \cell }{ID of target task \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type} \cell }{Message type \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i arg} \cell }{Additional argument data \cell }
{\row }
}
}{
Definition at line {\b 977} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a4f3960871e36fdf7234b151f81f04120_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a4f3960871e36fdf7234b151f81f04120_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setLogLevel\:Scheduler}
{\xe \v Scheduler\:setLogLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Scheduler::setLogLevel ({\b LogLevel}  {\i level})}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set minimum log level. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i level} \cell }{Minimum level to display \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Messages below this level will be filtered out \par
}}}{
Definition at line {\b 999} of file {\b FsmOS.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a612b33338832de0d18ebf5859b3d7037_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v stop\:Scheduler}
{\xe \v Scheduler\:stop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Scheduler::stop ()}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stop the scheduler. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stops all tasks and halts scheduling \par
}{
Definition at line {\b 963} of file {\b FsmOS.cpp}.}\par
}
{\xe \v updateSystemTime\:Scheduler}
{\xe \v Scheduler\:updateSystemTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Scheduler::updateSystemTime (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update system time. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Internal method to update system time from millis() \par
}{
Definition at line {\b 1107} of file {\b FsmOS.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a0a80134fcc4380c2577a5281352847eb_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v updateTaskStatistics\:Scheduler}
{\xe \v Scheduler\:updateTaskStatistics}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Scheduler::updateTaskStatistics ({\b Task} *  {\i task}, uint32_t  {\i execStart}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update task execution statistics. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i task} \cell }{{\b Task} to update \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i execStart} \cell }{Execution start time in microseconds \cell }
{\row }
}
}{
Definition at line {\b 1221} of file {\b FsmOS.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a23437fce9b79f76f4534c402e832d4f5_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v updateTimingVariables\:Scheduler}
{\xe \v Scheduler\:updateTimingVariables}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Scheduler::updateTimingVariables ({\b Task} *  {\i task}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update timing monitoring variables. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i task} \cell }{{\b Task} that was executed \cell }
{\row }
}
}{
Definition at line {\b 1271} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a6ee466fc5e47301d6101c246c691c131_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a6ee466fc5e47301d6101c246c691c131_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v wasResetCause\:Scheduler}
{\xe \v Scheduler\:wasResetCause}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Scheduler::wasResetCause ({\b ResetCause}  {\i cause})}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if a specific reset cause occurred. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cause} \cell }{Reset cause to check for \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the specified cause occurred \par
}}}{
Definition at line {\b 1500} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classScheduler_a1ad7c1772cfa11033b280e9b5de86d35_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Symbol Documentation\par
\pard\plain 
{\xe \v SharedMsg\:Scheduler}
{\xe \v Scheduler\:SharedMsg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b SharedMsg}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allow {\b SharedMsg} to access msgPool. }}\par
{
Definition at line {\b 1339} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v currentLogLevel\:Scheduler}
{\xe \v Scheduler\:currentLogLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b LogLevel} Scheduler::currentLogLevel{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current minimum log level. }}\par
{
Definition at line {\b 1333} of file {\b FsmOS.h}.}\par
}
{\xe \v freeHead\:Scheduler}
{\xe \v Scheduler\:freeHead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MsgNode}* Scheduler::freeHead = nullptr{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1473} of file {\b FsmOS.h}.}\par
}
{\xe \v freeTaskNodeHead\:Scheduler}
{\xe \v Scheduler\:freeTaskNodeHead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TaskNode}* Scheduler::freeTaskNodeHead = nullptr{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Head of free-list for {\b TaskNode} pool. }}\par
{
Definition at line {\b 1323} of file {\b FsmOS.h}.}\par
}
{\xe \v lastExecutedTaskId\:Scheduler}
{\xe \v Scheduler\:lastExecutedTaskId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Scheduler::lastExecutedTaskId = 0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ID of last executed task (for delay attribution) }}\par
{
Definition at line {\b 1336} of file {\b FsmOS.h}.}\par
}
{\xe \v lastTaskEndTime\:Scheduler}
{\xe \v Scheduler\:lastTaskEndTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Scheduler::lastTaskEndTime = 0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When the last task finished execution. }}\par
{
Definition at line {\b 1337} of file {\b FsmOS.h}.}\par
}
{\xe \v msgCount\:Scheduler}
{\xe \v Scheduler\:msgCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Scheduler::msgCount = 0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1474} of file {\b FsmOS.h}.}\par
}
{\xe \v msgHead\:Scheduler}
{\xe \v Scheduler\:msgHead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MsgNode}* Scheduler::msgHead = nullptr{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1471} of file {\b FsmOS.h}.}\par
}
{\xe \v msgPool\:Scheduler}
{\xe \v Scheduler\:msgPool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MsgDataPool} Scheduler::msgPool{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Message pool for efficient allocation. }}\par
{
Definition at line {\b 1329} of file {\b FsmOS.h}.}\par
}
{\xe \v msgTail\:Scheduler}
{\xe \v Scheduler\:msgTail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MsgNode}* Scheduler::msgTail = nullptr{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1472} of file {\b FsmOS.h}.}\par
}
{\xe \v nextTaskId\:Scheduler}
{\xe \v Scheduler\:nextTaskId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Scheduler::nextTaskId = 1{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Next available task ID. }}\par
{
Definition at line {\b 1327} of file {\b FsmOS.h}.}\par
}
{\xe \v running\:Scheduler}
{\xe \v Scheduler\:running}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Scheduler::running{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Scheduler} running state. }}\par
{
Definition at line {\b 1331} of file {\b FsmOS.h}.}\par
}
{\xe \v systemTime\:Scheduler}
{\xe \v Scheduler\:systemTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Scheduler::systemTime{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current system time. }}\par
{
Definition at line {\b 1330} of file {\b FsmOS.h}.}\par
}
{\xe \v taskCount\:Scheduler}
{\xe \v Scheduler\:taskCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Scheduler::taskCount = 0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current number of tasks. }}\par
{
Definition at line {\b 1326} of file {\b FsmOS.h}.}\par
}
{\xe \v taskHead\:Scheduler}
{\xe \v Scheduler\:taskHead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TaskNode}* Scheduler::taskHead = nullptr{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Head of task linked list. }}\par
{
Definition at line {\b 1320} of file {\b FsmOS.h}.}\par
}
{\xe \v taskNodePoolCapacity\:Scheduler}
{\xe \v Scheduler\:taskNodePoolCapacity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t Scheduler::taskNodePoolCapacity = 0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total nodes currently allocated to pool/list. }}\par
{
Definition at line {\b 1325} of file {\b FsmOS.h}.}\par
}
{\xe \v taskNodePoolInitialized\:Scheduler}
{\xe \v Scheduler\:taskNodePoolInitialized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Scheduler::taskNodePoolInitialized = false{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether pool has been initialized. }}\par
{
Definition at line {\b 1324} of file {\b FsmOS.h}.}\par
}
{\xe \v taskTail\:Scheduler}
{\xe \v Scheduler\:taskTail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TaskNode}* Scheduler::taskTail = nullptr{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tail of task linked list. }}\par
{
Definition at line {\b 1321} of file {\b FsmOS.h}.}\par
}
{\xe \v totalNodes\:Scheduler}
{\xe \v Scheduler\:totalNodes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Scheduler::totalNodes = 0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1475} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FsmOS.h}\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FsmOS.cpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Semaphore Class Reference\par \pard\plain 
{\tc\tcl2 \v Semaphore}
{\xe \v Semaphore}
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Semaphore} for resource counting and synchronization. }}\par
{
{\f2 #include <FsmOS.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Semaphore} (uint8_t initial_count, uint8_t {\b max_count})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b wait} (uint8_t task_id)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Try to acquire a resource. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b signal} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Release a resource. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b getCount} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get current resource count. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b getMaxCount} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get maximum resource count. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile uint8_t {\b count}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current resource count. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b max_count}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum resource count. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Semaphore} for resource counting and synchronization. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Semaphore} allows a limited number of tasks to access a resource simultaneously. It maintains a count of available resources.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
This semaphore is designed for cooperative multitasking only. Tasks must check {\b wait()} and yield if no resources are available. \par
}}}{
Definition at line {\b 590} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Semaphore\:Semaphore}
{\xe \v Semaphore\:Semaphore}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Semaphore::Semaphore (uint8_t  {\i initial_count}, uint8_t  {\i max_count})}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i initial_count} \cell }{Initial number of available resources \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i max_count} \cell }{Maximum number of resources \cell }
{\row }
}
}{
Definition at line {\b 426} of file {\b FsmOS.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getCount\:Semaphore}
{\xe \v Semaphore\:getCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Semaphore::getCount () const}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get current resource count. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Number of available resources \par
}}}{
Definition at line {\b 453} of file {\b FsmOS.cpp}.}\par
}
{\xe \v getMaxCount\:Semaphore}
{\xe \v Semaphore\:getMaxCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Semaphore::getMaxCount () const}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get maximum resource count. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Maximum number of resources \par
}}}{
Definition at line {\b 455} of file {\b FsmOS.cpp}.}\par
}
{\xe \v signal\:Semaphore}
{\xe \v Semaphore\:signal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Semaphore::signal ()}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Release a resource. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Increments the available resource count \par
}}}{
Definition at line {\b 442} of file {\b FsmOS.cpp}.}\par
}
{\xe \v wait\:Semaphore}
{\xe \v Semaphore\:wait}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Semaphore::wait (uint8_t  {\i task_id})}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Try to acquire a resource. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i task_id} \cell }{ID of the task attempting to acquire resource \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if resource was acquired, false if none available \par
}}}{
Definition at line {\b 428} of file {\b FsmOS.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v count\:Semaphore}
{\xe \v Semaphore\:count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile uint8_t Semaphore::count{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current resource count. }}\par
{
Definition at line {\b 626} of file {\b FsmOS.h}.}\par
}
{\xe \v max_count\:Semaphore}
{\xe \v Semaphore\:max_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Semaphore::max_count{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum resource count. }}\par
{
Definition at line {\b 627} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FsmOS.h}\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FsmOS.cpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SharedMsg Class Reference\par \pard\plain 
{\tc\tcl2 \v SharedMsg}
{\xe \v SharedMsg}
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Smart pointer-like wrapper for MsgData with reference counting. }}\par
{
{\f2 #include <FsmOS.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SharedMsg} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SharedMsg} (MsgData *data)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor from MsgData pointer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SharedMsg} (const {\b SharedMsg} &other)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SharedMsg} & {\b operator=} (const {\b SharedMsg} &other)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assignment operator. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~SharedMsg} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
MsgData * {\b getData} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get raw MsgData pointer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
MsgData * {\b operator->} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Arrow operator for direct access to MsgData. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isValid} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if {\b SharedMsg} contains valid data. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b release} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Internal method to release reference. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
MsgData * {\b msgData}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to the wrapped MsgData. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Smart pointer-like wrapper for MsgData with reference counting. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SharedMsg} provides automatic memory management for messages through reference counting. When the last reference is destroyed, the message is automatically returned to the pool.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
This class is thread-safe for single-threaded cooperative multitasking. \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Do not use across different scheduler instances. \par
}}}{
Definition at line {\b 313} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v SharedMsg\:SharedMsg}
{\xe \v SharedMsg\:SharedMsg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SharedMsg::SharedMsg ()}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates an empty {\b SharedMsg} with no associated data \par
}{
Definition at line {\b 103} of file {\b FsmOS.cpp}.}\par
}
{\xe \v SharedMsg\:SharedMsg}
{\xe \v SharedMsg\:SharedMsg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SharedMsg::SharedMsg (MsgData *  {\i data}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor from MsgData pointer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{Pointer to MsgData to wrap \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Increments reference count of the message \par
}}}{
Definition at line {\b 105} of file {\b FsmOS.cpp}.}\par
}
{\xe \v SharedMsg\:SharedMsg}
{\xe \v SharedMsg\:SharedMsg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SharedMsg::SharedMsg (const {\b SharedMsg} &  {\i other})}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i other} \cell }{{\b SharedMsg} to copy from \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Increments reference count of the shared message \par
}}}{
Definition at line {\b 113} of file {\b FsmOS.cpp}.}\par
}
{\xe \v ~SharedMsg\:SharedMsg}
{\xe \v SharedMsg\:~SharedMsg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SharedMsg::~SharedMsg ()}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Decrements reference count and frees message if count reaches 0 \par
}}}{
Definition at line {\b 158} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classSharedMsg_a1819d3340c3fa3d00950eb087cd97131_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getData\:SharedMsg}
{\xe \v SharedMsg\:getData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MsgData * SharedMsg::getData () const}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get raw MsgData pointer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Pointer to MsgData, or nullptr if invalid \par
}}}{
Definition at line {\b 176} of file {\b FsmOS.cpp}.}\par
}
{\xe \v isValid\:SharedMsg}
{\xe \v SharedMsg\:isValid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SharedMsg::isValid () const}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if {\b SharedMsg} contains valid data. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if valid, false if empty or invalid \par
}}}{
Definition at line {\b 180} of file {\b FsmOS.cpp}.}\par
}
{\xe \v operator->\:SharedMsg}
{\xe \v SharedMsg\:operator->}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MsgData * SharedMsg::operator-> () const}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Arrow operator for direct access to MsgData. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Pointer to MsgData for member access \par
}}}{
Definition at line {\b 178} of file {\b FsmOS.cpp}.}\par
}
{\xe \v operator=\:SharedMsg}
{\xe \v SharedMsg\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SharedMsg} & SharedMsg::operator= (const {\b SharedMsg} &  {\i other})}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assignment operator. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i other} \cell }{{\b SharedMsg} to assign from \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Reference to this {\b SharedMsg} \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Properly manages reference counting \par
}}}{
Definition at line {\b 121} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classSharedMsg_ad7ce8df960b49c88f0d4264c23c93f81_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v release\:SharedMsg}
{\xe \v SharedMsg\:release}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SharedMsg::release (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Internal method to release reference. }}\par
{
Definition at line {\b 163} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classSharedMsg_a458f5ccc07be87e716ef117e2eb0bce9_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classSharedMsg_a458f5ccc07be87e716ef117e2eb0bce9_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v msgData\:SharedMsg}
{\xe \v SharedMsg\:msgData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MsgData* SharedMsg::msgData{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to the wrapped MsgData. }}\par
{
Definition at line {\b 369} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FsmOS.h}\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FsmOS.cpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SystemMemoryInfo Struct Reference\par \pard\plain 
{\tc\tcl2 \v SystemMemoryInfo}
{\xe \v SystemMemoryInfo}
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
System memory information. }}\par
{
{\f2 #include <FsmOS.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b freeRam}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Free RAM in bytes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b totalRam}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total RAM in bytes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b heapSize}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Heap size in bytes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b largestBlock}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Largest free block in bytes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b heapFragments}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of heap fragments. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b stackSize}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stack size in bytes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b stackUsed}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stack used in bytes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b stackFree}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stack free in bytes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b totalTasks}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total number of tasks. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b taskMemory}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory used by tasks. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b activeMessages}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of active messages. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b messageMemory}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory used by messages. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b flashUsed}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flash memory used. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b flashFree}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flash memory free. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b eepromUsed}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
EEPROM used in bytes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b eepromFree}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
EEPROM free in bytes. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
System memory information. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Comprehensive memory usage statistics \par
}{
Definition at line {\b 196} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v activeMessages\:SystemMemoryInfo}
{\xe \v SystemMemoryInfo\:activeMessages}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t SystemMemoryInfo::activeMessages}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of active messages. }}\par
{
Definition at line {\b 208} of file {\b FsmOS.h}.}\par
}
{\xe \v eepromFree\:SystemMemoryInfo}
{\xe \v SystemMemoryInfo\:eepromFree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t SystemMemoryInfo::eepromFree}}
\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
EEPROM free in bytes. }}\par
{
Definition at line {\b 213} of file {\b FsmOS.h}.}\par
}
{\xe \v eepromUsed\:SystemMemoryInfo}
{\xe \v SystemMemoryInfo\:eepromUsed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t SystemMemoryInfo::eepromUsed}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
EEPROM used in bytes. }}\par
{
Definition at line {\b 212} of file {\b FsmOS.h}.}\par
}
{\xe \v flashFree\:SystemMemoryInfo}
{\xe \v SystemMemoryInfo\:flashFree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t SystemMemoryInfo::flashFree}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flash memory free. }}\par
{
Definition at line {\b 211} of file {\b FsmOS.h}.}\par
}
{\xe \v flashUsed\:SystemMemoryInfo}
{\xe \v SystemMemoryInfo\:flashUsed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t SystemMemoryInfo::flashUsed}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flash memory used. }}\par
{
Definition at line {\b 210} of file {\b FsmOS.h}.}\par
}
{\xe \v freeRam\:SystemMemoryInfo}
{\xe \v SystemMemoryInfo\:freeRam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t SystemMemoryInfo::freeRam}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Free RAM in bytes. }}\par
{
Definition at line {\b 198} of file {\b FsmOS.h}.}\par
}
{\xe \v heapFragments\:SystemMemoryInfo}
{\xe \v SystemMemoryInfo\:heapFragments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t SystemMemoryInfo::heapFragments}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of heap fragments. }}\par
{
Definition at line {\b 202} of file {\b FsmOS.h}.}\par
}
{\xe \v heapSize\:SystemMemoryInfo}
{\xe \v SystemMemoryInfo\:heapSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t SystemMemoryInfo::heapSize}}
\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Heap size in bytes. }}\par
{
Definition at line {\b 200} of file {\b FsmOS.h}.}\par
}
{\xe \v largestBlock\:SystemMemoryInfo}
{\xe \v SystemMemoryInfo\:largestBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t SystemMemoryInfo::largestBlock}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Largest free block in bytes. }}\par
{
Definition at line {\b 201} of file {\b FsmOS.h}.}\par
}
{\xe \v messageMemory\:SystemMemoryInfo}
{\xe \v SystemMemoryInfo\:messageMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t SystemMemoryInfo::messageMemory}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory used by messages. }}\par
{
Definition at line {\b 209} of file {\b FsmOS.h}.}\par
}
{\xe \v stackFree\:SystemMemoryInfo}
{\xe \v SystemMemoryInfo\:stackFree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t SystemMemoryInfo::stackFree}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stack free in bytes. }}\par
{
Definition at line {\b 205} of file {\b FsmOS.h}.}\par
}
{\xe \v stackSize\:SystemMemoryInfo}
{\xe \v SystemMemoryInfo\:stackSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t SystemMemoryInfo::stackSize}}
\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stack size in bytes. }}\par
{
Definition at line {\b 203} of file {\b FsmOS.h}.}\par
}
{\xe \v stackUsed\:SystemMemoryInfo}
{\xe \v SystemMemoryInfo\:stackUsed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t SystemMemoryInfo::stackUsed}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stack used in bytes. }}\par
{
Definition at line {\b 204} of file {\b FsmOS.h}.}\par
}
{\xe \v taskMemory\:SystemMemoryInfo}
{\xe \v SystemMemoryInfo\:taskMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t SystemMemoryInfo::taskMemory}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory used by tasks. }}\par
{
Definition at line {\b 207} of file {\b FsmOS.h}.}\par
}
{\xe \v totalRam\:SystemMemoryInfo}
{\xe \v SystemMemoryInfo\:totalRam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t SystemMemoryInfo::totalRam}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total RAM in bytes. }}\par
{
Definition at line {\b 199} of file {\b FsmOS.h}.}\par
}
{\xe \v totalTasks\:SystemMemoryInfo}
{\xe \v SystemMemoryInfo\:totalTasks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t SystemMemoryInfo::totalTasks}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total number of tasks. }}\par
{
Definition at line {\b 206} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FsmOS.h}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Task Class Reference\par \pard\plain 
{\tc\tcl2 \v Task}
{\xe \v Task}
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base class for all tasks in FsmOS. }}\par
{
{\f2 #include <FsmOS.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b Priority} \{ {\b PRIORITY_LOWEST} = 0
, {\b PRIORITY_LOW} = 1
, {\b PRIORITY_NORMAL} = 2
, {\b PRIORITY_HIGH} = 3
, {\b PRIORITY_HIGHEST} = 4
, {\b PRIORITY_CRITICAL} = 5
, {\b PRIORITY_REALTIME} = 6
, {\b PRIORITY_SYSTEM} = 7
, {\b PRIORITY_MAX} = 15
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} priority levels. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Task} (const __FlashStringHelper *{\b name}=nullptr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~Task} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Virtual destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b on_start} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when task is started. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b step} ()=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Main task execution method. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b on_stop} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when task is stopped. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b on_msg} (const MsgData &msg)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle incoming messages. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b start} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start the task. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b stop} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stop the task. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b suspend} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Suspend the task. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resume} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resume the task. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b terminate} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Terminate the task. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPeriod} (uint16_t period_ms)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set task execution period. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b getPeriod} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get task execution period. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPriority} ({\b Priority} priority)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set task priority. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPriority} (uint8_t priority)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set task priority (legacy) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b getPriority} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get task priority. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMaxMessageBudget} (uint8_t budget)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Declare the maximum number of messages this task may produce in one {\b step()} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual uint8_t {\b getMaxMessageBudget} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the maximum number of messages this task may produce in one {\b step()} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual uint16_t {\b getTaskStructSize} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the size in bytes of the concrete task object. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static uint16_t {\b getCreatedInstanceCount} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get total number of {\b Task} instances ever created. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const __FlashStringHelper * {\b readTaskName} (const {\b Task} *t)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Public helper to read another task's name safely from diagnostics. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b State} \{ {\b INACTIVE}
, {\b ACTIVE}
, {\b SUSPENDED}
, {\b TERMINATED}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} state enumeration. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b getConfiguredMessageBudget} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Access the configured budget set via {\b setMaxMessageBudget()} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b State} {\b getState} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get current task state. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setState} ({\b State} newState)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set task state. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b checkState} ({\b State} expected) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if task is in expected state. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isActive} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if task is active. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInactive} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if task is inactive. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b getId} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get unique task ID. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const __FlashStringHelper * {\b getName} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get task name. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setName} (const __FlashStringHelper *{\b name})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set task name. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b subscribe} (uint8_t topic)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subscribe to a message topic. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b unsubscribe} (uint8_t topic)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Unsubscribe from a message topic. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isSubscribedToTopic} (uint8_t topic) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if task is subscribed to a topic. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b getTopicCount} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the number of subscribed topics. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b publish} (uint8_t topic, uint8_t type, uint16_t arg=0)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Publish a message to a topic. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b tell} (uint8_t task_id, uint8_t type, uint16_t arg=0)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Send a direct message to a specific task. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b log} (const __FlashStringHelper *msg)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log an info message. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logDebug} (const __FlashStringHelper *msg)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log a debug message. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logInfo} (const __FlashStringHelper *msg)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log an info message. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logWarn} (const __FlashStringHelper *msg)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log a warning message. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logError} (const __FlashStringHelper *msg)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log an error message. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > T {\b createTimerTyped} (uint32_t duration_ms) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a memory-optimized timer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b processMessages} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process pending messages for this task. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b getDelayCount} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get number of times this task was delayed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b getMaxDelay} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get maximum delay experienced by this task. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b getScheduledTime} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get scheduled execution time. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b getActualStartTime} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get actual start time of last execution. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b remainingTime} = 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remaining time until next execution (in ms) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b periodMs} = 1\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} execution period in milliseconds. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b taskId} = 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Unique task identifier. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b stateAndPriority} = 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Combined state and priority (4 bits each) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const __FlashStringHelper * {\b name}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} name for debugging. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b runCount} = 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of times task has run (16-bit for space) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b maxExecTimeUs} = 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum execution time in microseconds (16-bit) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b avgExecTimeUs} = 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Average execution time in microseconds (16-bit) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b scheduledTime} = 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When this task was scheduled to run. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b actualStartTime} = 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When this task actually started running. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b delayCount} = 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of times this task was delayed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b maxDelayMs} = 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum delay experienced in milliseconds. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TopicBitfield} {\b subscribedTopics} = 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bitfield for subscribed topics. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b maxMessageBudget} = 0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Private Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static uint16_t {\b createdInstanceCount} = 0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Scheduler}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base class for all tasks in FsmOS. \par
}{
Definition at line {\b 653} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v Priority\:Task}
{\xe \v Task\:Priority}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Task::Priority}}}
\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} priority levels. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Priority levels for task scheduling \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v PRIORITY_LOWEST\:Task}
{\xe \v Task\:PRIORITY_LOWEST}
{\qr PRIORITY_LOWEST{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lowest priority (0) \par
}\cell }{\row }
{\xe \v PRIORITY_LOW\:Task}
{\xe \v Task\:PRIORITY_LOW}
{\qr PRIORITY_LOW{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Low priority (1) \par
}\cell }{\row }
{\xe \v PRIORITY_NORMAL\:Task}
{\xe \v Task\:PRIORITY_NORMAL}
{\qr PRIORITY_NORMAL{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Normal priority (2) \par
}\cell }{\row }
{\xe \v PRIORITY_HIGH\:Task}
{\xe \v Task\:PRIORITY_HIGH}
{\qr PRIORITY_HIGH{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
High priority (3) \par
}\cell }{\row }
{\xe \v PRIORITY_HIGHEST\:Task}
{\xe \v Task\:PRIORITY_HIGHEST}
{\qr PRIORITY_HIGHEST{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Highest priority (4) \par
}\cell }{\row }
{\xe \v PRIORITY_CRITICAL\:Task}
{\xe \v Task\:PRIORITY_CRITICAL}
{\qr PRIORITY_CRITICAL{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Critical priority (5) \par
}\cell }{\row }
{\xe \v PRIORITY_REALTIME\:Task}
{\xe \v Task\:PRIORITY_REALTIME}
{\qr PRIORITY_REALTIME{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Real-time priority (6) \par
}\cell }{\row }
{\xe \v PRIORITY_SYSTEM\:Task}
{\xe \v Task\:PRIORITY_SYSTEM}
{\qr PRIORITY_SYSTEM{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
System priority (7) \par
}\cell }{\row }
{\xe \v PRIORITY_MAX\:Task}
{\xe \v Task\:PRIORITY_MAX}
{\qr PRIORITY_MAX{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum priority (15) \par
}\cell }{\row }
}
{
Definition at line {\b 754} of file {\b FsmOS.h}.}\par
}
{\xe \v State\:Task}
{\xe \v Task\:State}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Task::State}{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} state enumeration. }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v INACTIVE\:Task}
{\xe \v Task\:INACTIVE}
{\qr INACTIVE{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} is not running. \par
}\cell }{\row }
{\xe \v ACTIVE\:Task}
{\xe \v Task\:ACTIVE}
{\qr ACTIVE{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} is running and scheduled. \par
}\cell }{\row }
{\xe \v SUSPENDED\:Task}
{\xe \v Task\:SUSPENDED}
{\qr SUSPENDED{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} is paused. \par
}\cell }{\row }
{\xe \v TERMINATED\:Task}
{\xe \v Task\:TERMINATED}
{\qr TERMINATED{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} is marked for removal. \par
}\cell }{\row }
}
{
Definition at line {\b 820} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Task\:Task}
{\xe \v Task\:Task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Task::Task (const __FlashStringHelper *  {\i name} = {\f2 nullptr}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i name} \cell }{Optional name for the task (for debugging)\cell }
{\row }
}
Creates a new task in INACTIVE state \par
}{
Definition at line {\b 460} of file {\b FsmOS.cpp}.}\par
}
{\xe \v ~Task\:Task}
{\xe \v Task\:~Task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Task::~Task (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Virtual destructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ensures proper cleanup of derived classes \par
}{
Definition at line {\b 471} of file {\b FsmOS.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v checkState\:Task}
{\xe \v Task\:checkState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Task::checkState ({\b State}  {\i expected}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if task is in expected state. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i expected} \cell }{Expected state to check against \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if task is in expected state \par
}}}{
Definition at line {\b 540} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_af770c80b9b06c6f314441144dcb6b117_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v createTimerTyped\:Task}
{\xe \v Task\:createTimerTyped}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > template {\b Timer32} Task::createTimerTyped< {\b Timer32} > (uint32_t  {\i duration_ms}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a memory-optimized timer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i T} \cell }{Timer type (Timer8, Timer16, Timer32) \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i duration_ms} \cell }{Duration in milliseconds \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Timer object ready to use \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Choose timer type based on expected duration for memory optimization \par
}}}{
Definition at line {\b 575} of file {\b FsmOS.cpp}.}\par
}
{\xe \v getActualStartTime\:Task}
{\xe \v Task\:getActualStartTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Task::getActualStartTime () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get actual start time of last execution. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Actual start time in milliseconds \par
}}}{
Definition at line {\b 614} of file {\b FsmOS.cpp}.}\par
}
{\xe \v getConfiguredMessageBudget\:Task}
{\xe \v Task\:getConfiguredMessageBudget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Task::getConfiguredMessageBudget () const{\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Access the configured budget set via {\b setMaxMessageBudget()} }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The configured budget value \par
}}}{
Definition at line {\b 814} of file {\b FsmOS.h}.}\par
}
{\xe \v getCreatedInstanceCount\:Task}
{\xe \v Task\:getCreatedInstanceCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static uint16_t Task::getCreatedInstanceCount (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get total number of {\b Task} instances ever created. }}\par
{
Definition at line {\b 672} of file {\b FsmOS.h}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_a42a50afac20691fb27694ca04ccc4e90_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getDelayCount\:Task}
{\xe \v Task\:getDelayCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t Task::getDelayCount () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get number of times this task was delayed. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Number of delay occurrences \par
}}}{
Definition at line {\b 599} of file {\b FsmOS.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_ac5ab04209706d6b3a0fdd5266dc0d97f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getId\:Task}
{\xe \v Task\:getId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Task::getId () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get unique task ID. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b Task} ID assigned by scheduler \par
}}}{
Definition at line {\b 546} of file {\b FsmOS.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_a548d620b8f5d7490b8cdc235dbfdf6eb_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getMaxDelay\:Task}
{\xe \v Task\:getMaxDelay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t Task::getMaxDelay () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get maximum delay experienced by this task. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Maximum delay in milliseconds \par
}}}{
Definition at line {\b 604} of file {\b FsmOS.cpp}.}\par
}
{\xe \v getName\:Task}
{\xe \v Task\:getName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const __FlashStringHelper * Task::getName () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get task name. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b Task} name string \par
}}}{
Definition at line {\b 548} of file {\b FsmOS.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_aae9b70f6c6542469cd8c3c122536964c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getPeriod\:Task}
{\xe \v Task\:getPeriod}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t Task::getPeriod () const}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get task execution period. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Period in milliseconds \par
}}}{
Definition at line {\b 522} of file {\b FsmOS.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_aa096c58dddc4fb8f7f8d5f40e1815d2d_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getPriority\:Task}
{\xe \v Task\:getPriority}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Task::getPriority () const}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get task priority. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Priority level \par
}}}{
Definition at line {\b 528} of file {\b FsmOS.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_aef8cf69a9b677977003d8b72d66d36d8_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getScheduledTime\:Task}
{\xe \v Task\:getScheduledTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Task::getScheduledTime () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get scheduled execution time. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Scheduled time in milliseconds \par
}}}{
Definition at line {\b 609} of file {\b FsmOS.cpp}.}\par
}
{\xe \v getState\:Task}
{\xe \v Task\:getState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Task::State} Task::getState () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get current task state. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Current state of the task \par
}}}{
Definition at line {\b 536} of file {\b FsmOS.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_acccd11864edfa1abbb15ff43008a17ec_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getTaskStructSize\:Task}
{\xe \v Task\:getTaskStructSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual uint16_t Task::getTaskStructSize () const{\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the size in bytes of the concrete task object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implement in each derived {\b Task} as: return sizeof(DerivedClass); \par
}{
Definition at line {\b 807} of file {\b FsmOS.h}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_aea07a4be09d08cb8b1afa1914ddc988c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v getTopicCount\:Task}
{\xe \v Task\:getTopicCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Task::getTopicCount () const{\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the number of subscribed topics. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Number of subscribed topics \par
}}}{
Definition at line {\b 928} of file {\b FsmOS.h}.}\par
}
{\xe \v isActive\:Task}
{\xe \v Task\:isActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Task::isActive () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if task is active. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if task is in ACTIVE state \par
}}}{
Definition at line {\b 542} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_a14f40317936f729e291a81fcf4426466_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_a14f40317936f729e291a81fcf4426466_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isInactive\:Task}
{\xe \v Task\:isInactive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Task::isInactive () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if task is inactive. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if task is in INACTIVE state \par
}}}{
Definition at line {\b 544} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_abee024294d3599db8917a96cab0a55f2_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v isSubscribedToTopic\:Task}
{\xe \v Task\:isSubscribedToTopic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Task::isSubscribedToTopic (uint8_t  {\i topic}) const{\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if task is subscribed to a topic. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i topic} \cell }{Topic ID to check \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if subscribed, false otherwise \par
}}}{
Definition at line {\b 915} of file {\b FsmOS.h}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_a1f356af32a2d49b158ead810225d00be_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v log\:Task}
{\xe \v Task\:log}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Task::log (const __FlashStringHelper *  {\i msg}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log an info message. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i msg} \cell }{Message to log \cell }
{\row }
}
}{
Definition at line {\b 564} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_a8bc9456ebb7dfbb657f040320af1a6ef_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v logDebug\:Task}
{\xe \v Task\:logDebug}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Task::logDebug (const __FlashStringHelper *  {\i msg}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log a debug message. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i msg} \cell }{Message to log \cell }
{\row }
}
}{
Definition at line {\b 566} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_aa961a934509f354a023b8f32d3656e95_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v logError\:Task}
{\xe \v Task\:logError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Task::logError (const __FlashStringHelper *  {\i msg}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log an error message. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i msg} \cell }{Message to log \cell }
{\row }
}
}{
Definition at line {\b 572} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_aa4c091b4c65870bd83c6111d23ecee21_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v logInfo\:Task}
{\xe \v Task\:logInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Task::logInfo (const __FlashStringHelper *  {\i msg}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log an info message. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i msg} \cell }{Message to log \cell }
{\row }
}
}{
Definition at line {\b 568} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_a24f4e032e0dd55e6e2e7ef44c715e9ca_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v logWarn\:Task}
{\xe \v Task\:logWarn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Task::logWarn (const __FlashStringHelper *  {\i msg}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log a warning message. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i msg} \cell }{Message to log \cell }
{\row }
}
}{
Definition at line {\b 570} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_a36592cc85ff1d08bf6cb2442055188f6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v on_msg\:Task}
{\xe \v Task\:on_msg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Task::on_msg (const MsgData &  {\i msg}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle incoming messages. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i msg} \cell }{The received message\cell }
{\row }
}
Override this method to handle specific message types \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Called automatically when messages are received \par
}}}{
Definition at line {\b 702} of file {\b FsmOS.h}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_a25e697fa851318504170fc4f3edf8308_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v on_start\:Task}
{\xe \v Task\:on_start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Task::on_start (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when task is started. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Override this method to perform initialization \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Called once when task transitions to ACTIVE state \par
}}}{
Definition at line {\b 680} of file {\b FsmOS.h}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_a05ad697fe4c99793e7af4dade75bad64_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v on_stop\:Task}
{\xe \v Task\:on_stop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Task::on_stop (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when task is stopped. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Override this method to perform cleanup \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Called when task transitions to INACTIVE state \par
}}}{
Definition at line {\b 694} of file {\b FsmOS.h}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_a7eccc77f654e53524d3a07b1ef73c83c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v processMessages\:Task}
{\xe \v Task\:processMessages}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Task::processMessages (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process pending messages for this task. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Called automatically by scheduler, rarely needs direct use \par
}}}{
Definition at line {\b 592} of file {\b FsmOS.cpp}.}\par
}
{\xe \v publish\:Task}
{\xe \v Task\:publish}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Task::publish (uint8_t  {\i topic}, uint8_t  {\i type}, uint16_t  {\i arg} = {\f2 0}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Publish a message to a topic. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i topic} \cell }{Topic ID to publish to \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type} \cell }{Message type \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i arg} \cell }{Additional argument data \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
All subscribed tasks will receive this message \par
}}}{
Definition at line {\b 554} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_a4b2cce5377f8ddf0cc29d00a3c58c1c0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v readTaskName\:Task}
{\xe \v Task\:readTaskName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static const __FlashStringHelper * Task::readTaskName (const {\b Task} *  {\i t}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Public helper to read another task's name safely from diagnostics. }}\par
{
Definition at line {\b 875} of file {\b FsmOS.h}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_a5a90bf718dcc0fad7285e1ae580d47df_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v resume\:Task}
{\xe \v Task\:resume}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Task::resume ()}}
\par
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resume the task. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} returns to scheduling queue \par
}{
Definition at line {\b 506} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_a8fc7f3a2f5ebd910f22d1134d0dfcb2f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v setMaxMessageBudget\:Task}
{\xe \v Task\:setMaxMessageBudget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Task::setMaxMessageBudget (uint8_t  {\i budget})}}
\par
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Declare the maximum number of messages this task may produce in one {\b step()} }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used by the scheduler to avoid running producers when the global message queue has fewer free slots than the declared budget. 0 disables gating. \par
}{
Definition at line {\b 530} of file {\b FsmOS.cpp}.}\par
}
{\xe \v setName\:Task}
{\xe \v Task\:setName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Task::setName (const __FlashStringHelper *  {\i name}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set task name. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i name} \cell }{New name for the task \cell }
{\row }
}
}{
Definition at line {\b 550} of file {\b FsmOS.cpp}.}\par
}
{\xe \v setPeriod\:Task}
{\xe \v Task\:setPeriod}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Task::setPeriod (uint16_t  {\i period_ms})}}
\par
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set task execution period. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i period_ms} \cell }{Period in milliseconds \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Minimum period is 1ms, maximum is 65535ms \par
}}}{
Definition at line {\b 517} of file {\b FsmOS.cpp}.}\par
}
{\xe \v setPriority\:Task}
{\xe \v Task\:setPriority}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Task::setPriority ({\b Priority}  {\i priority})}}
\par
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set task priority. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i priority} \cell }{Priority level\cell }
{\row }
}
Sets the task priority for scheduling \par
}{
Definition at line {\b 524} of file {\b FsmOS.cpp}.}\par
}
{\xe \v setPriority\:Task}
{\xe \v Task\:setPriority}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Task::setPriority (uint8_t  {\i priority})}}
\par
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set task priority (legacy) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i priority} \cell }{Priority level (0-15)\cell }
{\row }
}
Sets the task priority for scheduling \par
}{
Definition at line {\b 526} of file {\b FsmOS.cpp}.}\par
}
{\xe \v setState\:Task}
{\xe \v Task\:setState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Task::setState ({\b State}  {\i newState}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set task state. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i newState} \cell }{New state to set \cell }
{\row }
}
}{
Definition at line {\b 538} of file {\b FsmOS.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_a7a79169eed523ffdafa76f3c9d07ff27_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v start\:Task}
{\xe \v Task\:start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Task::start ()}}
\par
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start the task. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Transitions task to ACTIVE state and calls {\b on_start()} \par
}{
Definition at line {\b 479} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_a5d6a1d3c6cd5b587d2414737fab9f3ed_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_a5d6a1d3c6cd5b587d2414737fab9f3ed_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v step\:Task}
{\xe \v Task\:step}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Task::step (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Main task execution method. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method is called periodically by the scheduler \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Must be implemented by derived classes \par
}}}Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_a399ff82ffe4b94a11cd8148987e38622_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v stop\:Task}
{\xe \v Task\:stop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Task::stop ()}}
\par
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stop the task. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Transitions task to INACTIVE state and calls {\b on_stop()} \par
}{
Definition at line {\b 489} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_aba5eb3d6c2a034aa0e319383fbec68c4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_aba5eb3d6c2a034aa0e319383fbec68c4_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v subscribe\:Task}
{\xe \v Task\:subscribe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Task::subscribe (uint8_t  {\i topic}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subscribe to a message topic. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i topic} \cell }{Topic ID to subscribe to \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b Task} will receive messages published to this topic \par
}}}{
Definition at line {\b 890} of file {\b FsmOS.h}.}\par
}
{\xe \v suspend\:Task}
{\xe \v Task\:suspend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Task::suspend ()}}
\par
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Suspend the task. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} remains in memory but is not scheduled \par
}{
Definition at line {\b 498} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_ae95f8af6f74b4c956b82698b98454cd2_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v tell\:Task}
{\xe \v Task\:tell}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Task::tell (uint8_t  {\i task_id}, uint8_t  {\i type}, uint16_t  {\i arg} = {\f2 0}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Send a direct message to a specific task. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i task_id} \cell }{ID of target task \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type} \cell }{Message type \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i arg} \cell }{Additional argument data \cell }
{\row }
}
}{
Definition at line {\b 559} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_adbd4d278e42780bd4b6c1d918d0f85c9_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v terminate\:Task}
{\xe \v Task\:terminate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Task::terminate ()}}
\par
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Terminate the task. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Marks task for removal from scheduler \par
}{
Definition at line {\b 515} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classTask_a4401622acef8826077250b6b9e24e477_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v unsubscribe\:Task}
{\xe \v Task\:unsubscribe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Task::unsubscribe (uint8_t  {\i topic}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Unsubscribe from a message topic. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i topic} \cell }{Topic ID to unsubscribe from \cell }
{\row }
}
}{
Definition at line {\b 902} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Symbol Documentation\par
\pard\plain 
{\xe \v Scheduler\:Task}
{\xe \v Task\:Scheduler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b Scheduler}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1030} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v actualStartTime\:Task}
{\xe \v Task\:actualStartTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Task::actualStartTime = 0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When this task actually started running. }}\par
{
Definition at line {\b 1045} of file {\b FsmOS.h}.}\par
}
{\xe \v avgExecTimeUs\:Task}
{\xe \v Task\:avgExecTimeUs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t Task::avgExecTimeUs = 0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Average execution time in microseconds (16-bit) }}\par
{
Definition at line {\b 1041} of file {\b FsmOS.h}.}\par
}
{\xe \v createdInstanceCount\:Task}
{\xe \v Task\:createdInstanceCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t Task::createdInstanceCount = 0{\f2 [static]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1055} of file {\b FsmOS.h}.}\par
}
{\xe \v delayCount\:Task}
{\xe \v Task\:delayCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t Task::delayCount = 0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of times this task was delayed. }}\par
{
Definition at line {\b 1046} of file {\b FsmOS.h}.}\par
}
{\xe \v maxDelayMs\:Task}
{\xe \v Task\:maxDelayMs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t Task::maxDelayMs = 0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum delay experienced in milliseconds. }}\par
{
Definition at line {\b 1047} of file {\b FsmOS.h}.}\par
}
{\xe \v maxExecTimeUs\:Task}
{\xe \v Task\:maxExecTimeUs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t Task::maxExecTimeUs = 0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum execution time in microseconds (16-bit) }}\par
{
Definition at line {\b 1040} of file {\b FsmOS.h}.}\par
}
{\xe \v maxMessageBudget\:Task}
{\xe \v Task\:maxMessageBudget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Task::maxMessageBudget = 0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1052} of file {\b FsmOS.h}.}\par
}
{\xe \v name\:Task}
{\xe \v Task\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const __FlashStringHelper* Task::name{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} name for debugging. }}\par
{
Definition at line {\b 1036} of file {\b FsmOS.h}.}\par
}
{\xe \v periodMs\:Task}
{\xe \v Task\:periodMs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t Task::periodMs = 1{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} execution period in milliseconds. }}\par
{
Definition at line {\b 1033} of file {\b FsmOS.h}.}\par
}
{\xe \v remainingTime\:Task}
{\xe \v Task\:remainingTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t Task::remainingTime = 0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remaining time until next execution (in ms) }}\par
{
Definition at line {\b 1032} of file {\b FsmOS.h}.}\par
}
{\xe \v runCount\:Task}
{\xe \v Task\:runCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t Task::runCount = 0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of times task has run (16-bit for space) }}\par
{
Definition at line {\b 1039} of file {\b FsmOS.h}.}\par
}
{\xe \v scheduledTime\:Task}
{\xe \v Task\:scheduledTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Task::scheduledTime = 0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When this task was scheduled to run. }}\par
{
Definition at line {\b 1044} of file {\b FsmOS.h}.}\par
}
{\xe \v stateAndPriority\:Task}
{\xe \v Task\:stateAndPriority}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Task::stateAndPriority = 0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Combined state and priority (4 bits each) }}\par
{
Definition at line {\b 1035} of file {\b FsmOS.h}.}\par
}
{\xe \v subscribedTopics\:Task}
{\xe \v Task\:subscribedTopics}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TopicBitfield} Task::subscribedTopics = 0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bitfield for subscribed topics. }}\par
{
Definition at line {\b 1049} of file {\b FsmOS.h}.}\par
}
{\xe \v taskId\:Task}
{\xe \v Task\:taskId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Task::taskId = 0{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Unique task identifier. }}\par
{
Definition at line {\b 1034} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FsmOS.h}\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FsmOS.cpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TaskMemoryInfo Struct Reference\par \pard\plain 
{\tc\tcl2 \v TaskMemoryInfo}
{\xe \v TaskMemoryInfo}
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} memory information. }}\par
{
{\f2 #include <FsmOS.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b task_id}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} identifier. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b task_struct_size}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Size of task structure. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b subscription_size}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Size of subscription data. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b queue_size}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Size of message queue. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b total_allocated}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total memory allocated for task. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} memory information. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory usage statistics for individual tasks \par
}{
Definition at line {\b 221} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v queue_size\:TaskMemoryInfo}
{\xe \v TaskMemoryInfo\:queue_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t TaskMemoryInfo::queue_size}}
\par
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Size of message queue. }}\par
{
Definition at line {\b 226} of file {\b FsmOS.h}.}\par
}
{\xe \v subscription_size\:TaskMemoryInfo}
{\xe \v TaskMemoryInfo\:subscription_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t TaskMemoryInfo::subscription_size}}
\par
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Size of subscription data. }}\par
{
Definition at line {\b 225} of file {\b FsmOS.h}.}\par
}
{\xe \v task_id\:TaskMemoryInfo}
{\xe \v TaskMemoryInfo\:task_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t TaskMemoryInfo::task_id}}
\par
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} identifier. }}\par
{
Definition at line {\b 223} of file {\b FsmOS.h}.}\par
}
{\xe \v task_struct_size\:TaskMemoryInfo}
{\xe \v TaskMemoryInfo\:task_struct_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t TaskMemoryInfo::task_struct_size}}
\par
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Size of task structure. }}\par
{
Definition at line {\b 224} of file {\b FsmOS.h}.}\par
}
{\xe \v total_allocated\:TaskMemoryInfo}
{\xe \v TaskMemoryInfo\:total_allocated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t TaskMemoryInfo::total_allocated}}
\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total memory allocated for task. }}\par
{
Definition at line {\b 227} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FsmOS.h}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TaskNode Struct Reference\par \pard\plain 
{\tc\tcl2 \v TaskNode}
{\xe \v TaskNode}
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Node structure for {\b Task} linked list. }}\par
{
{\f2 #include <FsmOS.h>}}\par
Collaboration diagram for TaskNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structTaskNode__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TaskNode} ({\b Task} *t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Task} * {\b task}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to the task. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TaskNode} * {\b next}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to next node. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Node structure for {\b Task} linked list. \par
}{
Definition at line {\b 100} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v TaskNode\:TaskNode}
{\xe \v TaskNode\:TaskNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TaskNode::TaskNode ({\b Task} *  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 105} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v next\:TaskNode}
{\xe \v TaskNode\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TaskNode}* TaskNode::next}}
\par
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to next node. }}\par
{
Definition at line {\b 103} of file {\b FsmOS.h}.}\par
}
{\xe \v task\:TaskNode}
{\xe \v TaskNode\:task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Task}* TaskNode::task}}
\par
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to the task. }}\par
{
Definition at line {\b 102} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FsmOS.h}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TaskStats Struct Reference\par \pard\plain 
{\tc\tcl2 \v TaskStats}
{\xe \v TaskStats}
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} execution statistics. }}\par
{
{\f2 #include <FsmOS.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b taskId}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} identifier. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const __FlashStringHelper * {\b name}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} name. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b state}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task state ({\b Task::State} enum value) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b periodMs}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} period in milliseconds. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b priority}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} priority. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b runCount}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of times task has run. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b maxExecTimeUs}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum execution time in microseconds. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b totalExecTimeUs}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total execution time in microseconds. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b stackUsage}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stack usage in bytes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b delayCount}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of times task was delayed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b maxDelayMs}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum delay experienced in milliseconds. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} execution statistics. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used for performance monitoring and debugging \par
}{
Definition at line {\b 127} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v delayCount\:TaskStats}
{\xe \v TaskStats\:delayCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t TaskStats::delayCount}}
\par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of times task was delayed. }}\par
{
Definition at line {\b 138} of file {\b FsmOS.h}.}\par
}
{\xe \v maxDelayMs\:TaskStats}
{\xe \v TaskStats\:maxDelayMs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t TaskStats::maxDelayMs}}
\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum delay experienced in milliseconds. }}\par
{
Definition at line {\b 139} of file {\b FsmOS.h}.}\par
}
{\xe \v maxExecTimeUs\:TaskStats}
{\xe \v TaskStats\:maxExecTimeUs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t TaskStats::maxExecTimeUs}}
\par
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum execution time in microseconds. }}\par
{
Definition at line {\b 135} of file {\b FsmOS.h}.}\par
}
{\xe \v name\:TaskStats}
{\xe \v TaskStats\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const __FlashStringHelper* TaskStats::name}}
\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} name. }}\par
{
Definition at line {\b 130} of file {\b FsmOS.h}.}\par
}
{\xe \v periodMs\:TaskStats}
{\xe \v TaskStats\:periodMs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t TaskStats::periodMs}}
\par
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} period in milliseconds. }}\par
{
Definition at line {\b 132} of file {\b FsmOS.h}.}\par
}
{\xe \v priority\:TaskStats}
{\xe \v TaskStats\:priority}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t TaskStats::priority}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} priority. }}\par
{
Definition at line {\b 133} of file {\b FsmOS.h}.}\par
}
{\xe \v runCount\:TaskStats}
{\xe \v TaskStats\:runCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t TaskStats::runCount}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of times task has run. }}\par
{
Definition at line {\b 134} of file {\b FsmOS.h}.}\par
}
{\xe \v stackUsage\:TaskStats}
{\xe \v TaskStats\:stackUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t TaskStats::stackUsage}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stack usage in bytes. }}\par
{
Definition at line {\b 137} of file {\b FsmOS.h}.}\par
}
{\xe \v state\:TaskStats}
{\xe \v TaskStats\:state}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t TaskStats::state}}
\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task state ({\b Task::State} enum value) }}\par
{
Definition at line {\b 131} of file {\b FsmOS.h}.}\par
}
{\xe \v taskId\:TaskStats}
{\xe \v TaskStats\:taskId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t TaskStats::taskId}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} identifier. }}\par
{
Definition at line {\b 129} of file {\b FsmOS.h}.}\par
}
{\xe \v totalExecTimeUs\:TaskStats}
{\xe \v TaskStats\:totalExecTimeUs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t TaskStats::totalExecTimeUs}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total execution time in microseconds. }}\par
{
Definition at line {\b 136} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FsmOS.h}}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
FsmOS.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v FsmOS.cpp}
{\xe \v FsmOS.cpp}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementation of the FsmOS cooperative task scheduler. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "FsmOS.h"}\par
{\f2 #include <stdarg.h>}\par
{\f2 #include "../../src/BuildMemoryInfo.h"}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <stdlib.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for FsmOS.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "FsmOS_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b printLogHeader} ({\b Scheduler::LogLevel} level)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b logFormattedV} ({\b Scheduler::LogLevel} level, const __FlashStringHelper *format, va_list args)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logDebugf} (const __FlashStringHelper *format,...)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default per-task message production budget. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logInfof} (const __FlashStringHelper *format,...)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log an info message with formatting. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logWarnf} (const __FlashStringHelper *format,...)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log a warning message with formatting. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logErrorf} (const __FlashStringHelper *format,...)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log an error message with formatting. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Scheduler} {\b OS}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Global scheduler instance. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MemoryStats} {\b fsmos_memory_stats} = \{0, 0, 0, 0\}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementation of the FsmOS cooperative task scheduler. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Aykut \'D6zdemir {\f2 aykutozdemirgyte@gmail.com} \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
2025-10-02\par
}}This file contains the implementation of the FsmOS scheduler and task management system. It provides:\par
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Task} scheduling and execution\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Message passing and event handling\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Memory management and monitoring\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
System diagnostics and profiling\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Hardware watchdog integration\par}
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
1.3.0 - Major refactoring and code organization \par
}}}{
Definition in file {\b FsmOS.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v logFormattedV\:FsmOS.cpp}
{\xe \v FsmOS.cpp\:logFormattedV}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void logFormattedV ({\b Scheduler::LogLevel}  {\i level}, const __FlashStringHelper *  {\i format}, va_list  {\i args}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1683} of file {\b FsmOS.cpp}.}\par
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "FsmOS_8cpp_a239a4328ae320786411ee555c3a20250_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "FsmOS_8cpp_a239a4328ae320786411ee555c3a20250_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v printLogHeader\:FsmOS.cpp}
{\xe \v FsmOS.cpp\:printLogHeader}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void printLogHeader ({\b Scheduler::LogLevel}  {\i level}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1657} of file {\b FsmOS.cpp}.}\par
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "FsmOS_8cpp_ade20b4a6bf510c7319a727cdf86ebe37_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v fsmos_memory_stats\:FsmOS.cpp}
{\xe \v FsmOS.cpp\:fsmos_memory_stats}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MemoryStats} fsmos_memory_stats = \{0, 0, 0, 0\}}}
\par
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b FsmOS.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
FsmOS.cpp\par \pard\plain 
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00019 {\cf21 #include "FsmOS.h"}\par
00020 {\cf21 #include <stdarg.h>}\par
00021 {\cf21 #include "../../src/BuildMemoryInfo.h"}\par
00022 {\cf21 #include <stdio.h>}\par
00023 {\cf21 #include <string.h>}\par
00024 {\cf21 #include <stdlib.h>}\par
00025 \par
00026 {\cf21 #if defined(__AVR__)}\par
00027 {\cf20 // Stream stdio directly to Serial to allow vfprintf_P without intermediate buffers}\par
00028 {\cf17 static} {\cf18 int} serial_putc({\cf18 char} c, FILE *)\par
00029 \{\par
00030     Serial.write(c);\par
00031     {\cf19 return} 0;\par
00032 \}\par
00033 {\cf17 static} FILE serial_stdout;\par
00034 {\cf17 static} {\cf18 void} init_stdio_to_serial()\par
00035 \{\par
00036     {\cf17 static} {\cf18 bool} inited = {\cf17 false};\par
00037     {\cf19 if} (inited)\par
00038     \{\par
00039         {\cf19 return};\par
00040     \}\par
00041     inited = {\cf17 true};\par
00042     fdev_setup_stream(&serial_stdout, serial_putc, {\cf17 nullptr}, _FDEV_SETUP_WRITE);\par
00043     stdout = &serial_stdout;\par
00044 \}\par
00045 {\cf21 #endif}\par
00046 \par
00047 {\cf20 /* ================== Global Variables ================== */}\par
00048 Scheduler OS;\par
00049 \par
00050 MemoryStats fsmos_memory_stats = \{0, 0, 0, 0\};\par
00051 \par
00052 {\cf20 /* ================== TimerT Implementation ================== */}\par
00053 {\cf17 template} <{\cf17 typename} T>\par
00054 {\cf18 void} TimerT<T>::startTimer(T d)\par
00055 \{\par
00056     startMs = {\cf17 static_cast<}T{\cf17 >}(OS.now());\par
00057     durationMs = d;\par
00058 \}\par
00059 \par
00060 {\cf17 template} <{\cf17 typename} T>\par
00061 {\cf18 bool} TimerT<T>::isExpired(){\cf17  const}\par
00062 {\cf17 }\{\par
00063     {\cf19 if} (durationMs == 0)\par
00064     \{\par
00065         {\cf19 return} {\cf17 true};\par
00066     \}\par
00067 \par
00068     T current_time = {\cf17 static_cast<}T{\cf17 >}(OS.now());\par
00069 \par
00070     {\cf20 // Handle timer overflow correctly using safer arithmetic}\par
00071     {\cf19 if} (current_time >= startMs)\par
00072     \{\par
00073         {\cf20 // No overflow case - simple subtraction}\par
00074         {\cf19 return} (current_time - startMs) >= durationMs;\par
00075     \}\par
00076     {\cf19 else}\par
00077     \{\par
00078         {\cf20 // Timer overflow occurred - calculate elapsed time correctly}\par
00079         T max_value = {\cf17 static_cast<}T{\cf17 >}(~static_cast<T>(0));\par
00080 \par
00081         {\cf20 // Calculate elapsed time: time before overflow + time after overflow}\par
00082         T elapsed_before_overflow = max_value - startMs + 1;\par
00083         T elapsed_after_overflow = current_time;\par
00084         T total_elapsed = elapsed_before_overflow + elapsed_after_overflow;\par
00085 \par
00086         {\cf20 // Check for overflow in the addition}\par
00087         {\cf19 if} (total_elapsed < elapsed_before_overflow)\par
00088         \{\par
00089             {\cf20 // Addition overflowed, timer definitely expired}\par
00090             {\cf19 return} {\cf17 true};\par
00091         \}\par
00092 \par
00093         {\cf19 return} total_elapsed >= durationMs;\par
00094     \}\par
00095 \}\par
00096 \par
00097 {\cf20 // Explicit template instantiations for common types}\par
00098 {\cf17 template} {\cf17 struct }TimerT<uint8_t>;\par
00099 {\cf17 template} {\cf17 struct }TimerT<uint16_t>;\par
00100 {\cf17 template} {\cf17 struct }TimerT<uint32_t>;\par
00101 \par
00102 {\cf20 /* ================== SharedMsg Implementation ================== */}\par
00103 SharedMsg::SharedMsg() : msgData(nullptr) \{\}\par
00104 \par
00105 SharedMsg::SharedMsg(MsgData *msg) : msgData(msg)\par
00106 \{\par
00107     {\cf19 if} (msgData)\par
00108     \{\par
00109         ATOMIC_BLOCK(ATOMIC_RESTORESTATE) \{ msgData->refCount++; \}\par
00110     \}\par
00111 \}\par
00112 \par
00113 SharedMsg::SharedMsg({\cf17 const} SharedMsg &other) : msgData(other.msgData)\par
00114 \{\par
00115     {\cf19 if} (msgData)\par
00116     \{\par
00117         ATOMIC_BLOCK(ATOMIC_RESTORESTATE) \{ msgData->refCount++; \}\par
00118     \}\par
00119 \}\par
00120 \par
00121 SharedMsg &SharedMsg::operator=({\cf17 const} SharedMsg &other)\par
00122 \{\par
00123     {\cf19 if} ({\cf17 this} != &other)\par
00124     \{\par
00125         {\cf20 // Avoid nested atomic blocks by doing the work outside atomic block}\par
00126         MsgData *oldData = msgData;\par
00127         MsgData *newData = other.msgData;\par
00128         MsgData *toDeallocate = {\cf17 nullptr};\par
00129 \par
00130         {\cf20 // Single atomic block for the entire operation}\par
00131         ATOMIC_BLOCK(ATOMIC_RESTORESTATE)\par
00132         \{\par
00133             {\cf19 if} (newData)\par
00134             \{\par
00135                 newData->refCount++;\par
00136             \}\par
00137             msgData = newData;\par
00138 \par
00139             {\cf19 if} (oldData)\par
00140             \{\par
00141                 oldData->refCount--;\par
00142                 {\cf19 if} (oldData->refCount == 0)\par
00143                 \{\par
00144                     toDeallocate = oldData;\par
00145                 \}\par
00146             \}\par
00147         \}\par
00148 \par
00149         {\cf20 // Deallocate outside atomic block if needed}\par
00150         {\cf19 if} (toDeallocate)\par
00151         \{\par
00152             OS.msgPool.deallocate(toDeallocate);\par
00153         \}\par
00154     \}\par
00155     {\cf19 return} *{\cf17 this};\par
00156 \}\par
00157 \par
00158 SharedMsg::~SharedMsg()\par
00159 \{\par
00160     ATOMIC_BLOCK(ATOMIC_RESTORESTATE) \{ release(); \}\par
00161 \}\par
00162 \par
00163 {\cf18 void} SharedMsg::release()\par
00164 \{\par
00165     {\cf19 if} (msgData)\par
00166     \{\par
00167         msgData->refCount--;\par
00168         {\cf19 if} (msgData->refCount == 0)\par
00169         \{\par
00170             OS.msgPool.deallocate(msgData);\par
00171         \}\par
00172         msgData = {\cf17 nullptr};\par
00173     \}\par
00174 \}\par
00175 \par
00176 MsgData *SharedMsg::getData(){\cf17  const }\{ {\cf19 return} msgData; \}\par
00177 \par
00178 MsgData *SharedMsg::operator->(){\cf17  const }\{ {\cf19 return} msgData; \}\par
00179 \par
00180 {\cf18 bool} SharedMsg::isValid(){\cf17  const }\{ {\cf19 return} msgData != {\cf17 nullptr}; \}\par
00181 \par
00182 {\cf20 /* ================== MsgDataPool Implementation ================== */}\par
00183 MsgDataPool::MsgDataPool()\par
00184     : pool(nullptr), poolSize(0), poolLimit(MAX_MESSAGE_POOL_SIZE), currentInUse(0), nextFree(0)\par
00185 \{\par
00186     {\cf20 // Don't allocate memory during static initialization}\par
00187     {\cf20 // Memory will be allocated lazily when first needed}\par
00188 \}\par
00189 \par
00190 MsgDataPool::~MsgDataPool()\par
00191 \{\par
00192     {\cf19 if} (pool)\par
00193     \{\par
00194         {\cf17 delete}[] pool;\par
00195         pool = {\cf17 nullptr};\par
00196     \}\par
00197 \}\par
00198 \par
00199 MsgData *MsgDataPool::allocate()\par
00200 \{\par
00201     {\cf20 // Lazy initialization - allocate pool if not already done}\par
00202     {\cf19 if} (!pool && !initialize())\par
00203     \{\par
00204         fsmos_memory_stats.total_allocated += {\cf17 sizeof}(MsgData) * poolLimit;\par
00205         {\cf19 return} {\cf17 nullptr};\par
00206     \}\par
00207 \par
00208     {\cf19 if} (currentInUse >= poolSize)\par
00209     \{\par
00210         {\cf19 return} {\cf17 nullptr};\par
00211     \}\par
00212 \par
00213     MsgData *msg = &pool[nextFree];\par
00214 \par
00215     {\cf20 // Reset message to initial state}\par
00216     msg->refCount = 0;\par
00217     msg->type = 0;\par
00218     msg->topic = 0;\par
00219     msg->arg = 0;\par
00220 \par
00221     currentInUse++;\par
00222     nextFree = (nextFree + 1) % poolSize;\par
00223 \par
00224     fsmos_memory_stats.current_usage += {\cf17 sizeof}(MsgData);\par
00225     {\cf19 if} (fsmos_memory_stats.current_usage > fsmos_memory_stats.peak_usage)\par
00226     \{\par
00227         fsmos_memory_stats.peak_usage = fsmos_memory_stats.current_usage;\par
00228     \}\par
00229 \par
00230     {\cf20 // Update adaptive limit based on usage}\par
00231     updateAdaptiveLimit();\par
00232 \par
00233     {\cf19 return} msg;\par
00234 \}\par
00235 \par
00236 {\cf18 void} MsgDataPool::deallocate(MsgData *msg)\par
00237 \{\par
00238     {\cf19 if} (!msg || !pool)\par
00239     \{\par
00240         {\cf19 return};\par
00241     \}\par
00242 \par
00243     {\cf20 // Reset message to initial state}\par
00244     msg->refCount = 0;\par
00245     msg->type = 0;\par
00246     msg->topic = 0;\par
00247     msg->arg = 0;\par
00248 \par
00249     currentInUse--;\par
00250 \par
00251     fsmos_memory_stats.current_usage -= {\cf17 sizeof}(MsgData);\par
00252     fsmos_memory_stats.total_freed += {\cf17 sizeof}(MsgData);\par
00253 \par
00254     {\cf20 // Update adaptive limit based on usage}\par
00255     updateAdaptiveLimit();\par
00256 \}\par
00257 \par
00258 {\cf18 void} MsgDataPool::updateAdaptiveLimit()\par
00259 \{\par
00260     {\cf20 // Simple adaptive algorithm: increase limit if we're using most of it}\par
00261     {\cf19 if} (currentInUse > (poolSize * 3) / 4 && poolSize < poolLimit)\par
00262     \{\par
00263         poolSize++;\par
00264     \}\par
00265     {\cf20 // Decrease limit if we're using very little}\par
00266     {\cf19 else} {\cf19 if} (currentInUse < poolSize / 4 && poolSize > 4)\par
00267     \{\par
00268         poolSize--;\par
00269     \}\par
00270 \}\par
00271 \par
00272 uint8_t MsgDataPool::getPoolSize(){\cf17  const }\{ {\cf19 return} poolSize; \}\par
00273 \par
00274 uint8_t MsgDataPool::getPoolLimit(){\cf17  const }\{ {\cf19 return} poolLimit; \}\par
00275 \par
00276 uint8_t MsgDataPool::getCurrentInUse(){\cf17  const }\{ {\cf19 return} currentInUse; \}\par
00277 \par
00278 {\cf18 bool} MsgDataPool::initialize()\par
00279 \{\par
00280     {\cf20 // If already initialized, return true}\par
00281     {\cf19 if} (pool != {\cf17 nullptr})\par
00282     \{\par
00283         {\cf19 return} {\cf17 true};\par
00284     \}\par
00285 \par
00286     {\cf20 // Try to allocate memory}\par
00287     pool = {\cf17 new} MsgData[poolLimit];\par
00288     {\cf19 if} (pool)\par
00289     \{\par
00290         poolSize = poolLimit;\par
00291         {\cf20 // Initialize all messages as free}\par
00292         {\cf19 for} (uint8_t i = 0; i < poolSize; i++)\par
00293         \{\par
00294             pool[i].refCount = 0;\par
00295             pool[i].type = 0;\par
00296             pool[i].topic = 0;\par
00297             pool[i].arg = 0;\par
00298         \}\par
00299         fsmos_memory_stats.total_allocated += {\cf17 sizeof}(MsgData) * poolLimit;\par
00300         {\cf19 return} {\cf17 true};\par
00301     \}\par
00302 \par
00303     {\cf20 // Log error if memory allocation fails}\par
00304     OS.logMessage({\cf17 nullptr}, Scheduler::LOG_ERROR, F({\cf22 "Msg pool alloc failed"}));\par
00305     {\cf19 return} {\cf17 false};\par
00306 \}\par
00307 \par
00308 {\cf20 /* ================== LinkedQueue Implementation ================== */}\par
00309 {\cf17 template} <{\cf17 typename} T>\par
00310 LinkedQueue<T>::LinkedQueue() : head(nullptr), tail(nullptr), count(0) \{\}\par
00311 \par
00312 {\cf17 template} <{\cf17 typename} T>\par
00313 LinkedQueue<T>::~LinkedQueue()\par
00314 \{\par
00315     {\cf19 while} (head)\par
00316     \{\par
00317         Node *temp = head;\par
00318         head = head->next;\par
00319         {\cf17 delete} temp;\par
00320     \}\par
00321 \}\par
00322 \par
00323 {\cf17 template} <{\cf17 typename} T>\par
00324 LinkedQueue<T>::LinkedQueue(LinkedQueue &&other) noexcept : head(other.head), tail(other.tail), count(other.count)\par
00325 \{\par
00326     other.head = {\cf17 nullptr};\par
00327     other.tail = {\cf17 nullptr};\par
00328     other.count = 0;\par
00329 \}\par
00330 \par
00331 {\cf17 template} <{\cf17 typename} T>\par
00332 {\cf18 void} LinkedQueue<T>::push({\cf17 const} T &item)\par
00333 \{\par
00334     Node *new_node = {\cf17 new} Node;\par
00335     {\cf19 if} (!new_node)\par
00336     \{\par
00337         {\cf19 return};    {\cf20 // Memory allocation failed}\par
00338     \}\par
00339 \par
00340     new_node->data = item;\par
00341     new_node->next = {\cf17 nullptr};\par
00342 \par
00343     {\cf19 if} (tail)\par
00344     \{\par
00345         tail->next = new_node;\par
00346     \}\par
00347     {\cf19 else}\par
00348     \{\par
00349         head = new_node;\par
00350     \}\par
00351     tail = new_node;\par
00352     count++;\par
00353 \}\par
00354 \par
00355 {\cf17 template} <{\cf17 typename} T>\par
00356 {\cf18 bool} LinkedQueue<T>::pop(T &item)\par
00357 \{\par
00358     {\cf19 if} (!head)\par
00359     \{\par
00360         {\cf19 return} {\cf17 false};\par
00361     \}\par
00362 \par
00363     Node *temp = head;\par
00364     item = temp->data;  {\cf20 // This properly handles SharedMsg reference counting}\par
00365     head = head->next;\par
00366 \par
00367     {\cf19 if} (!head)\par
00368     \{\par
00369         tail = {\cf17 nullptr};\par
00370     \}\par
00371 \par
00372     {\cf17 delete} temp;\par
00373     count--;\par
00374     {\cf19 return} {\cf17 true};\par
00375 \}\par
00376 \par
00377 {\cf17 template} <{\cf17 typename} T>\par
00378 {\cf18 bool} LinkedQueue<T>::isEmpty(){\cf17  const}\par
00379 {\cf17 }\{\par
00380     {\cf19 return} head == {\cf17 nullptr};\par
00381 \}\par
00382 \par
00383 {\cf17 template} <{\cf17 typename} T>\par
00384 uint8_t LinkedQueue<T>::getSize(){\cf17  const}\par
00385 {\cf17 }\{\par
00386     {\cf19 return} count;\par
00387 \}\par
00388 \par
00389 {\cf20 // Explicit template instantiations for common types}\par
00390 {\cf17 template} {\cf17 class }LinkedQueue<SharedMsg>;\par
00391 \par
00392 {\cf20 /* ================== Mutex Implementation ================== */}\par
00393 Mutex::Mutex() : locked(false), owner_id(0) \{\}\par
00394 \par
00395 {\cf18 bool} Mutex::tryLock(uint8_t task_id)\par
00396 \{\par
00397     ATOMIC_BLOCK(ATOMIC_RESTORESTATE)\par
00398     \{\par
00399         {\cf19 if} (!locked)\par
00400         \{\par
00401             locked = {\cf17 true};\par
00402             owner_id = task_id;\par
00403             {\cf19 return} {\cf17 true};\par
00404         \}\par
00405     \}\par
00406     {\cf19 return} {\cf17 false};\par
00407 \}\par
00408 \par
00409 {\cf18 void} Mutex::unlock(uint8_t task_id)\par
00410 \{\par
00411     ATOMIC_BLOCK(ATOMIC_RESTORESTATE)\par
00412     \{\par
00413         {\cf19 if} (locked && owner_id == task_id)\par
00414         \{\par
00415             locked = {\cf17 false};\par
00416             owner_id = 0;\par
00417         \}\par
00418     \}\par
00419 \}\par
00420 \par
00421 {\cf18 bool} Mutex::isLocked(){\cf17  const }\{ {\cf19 return} locked; \}\par
00422 \par
00423 uint8_t Mutex::getOwner(){\cf17  const }\{ {\cf19 return} owner_id; \}\par
00424 \par
00425 {\cf20 /* ================== Semaphore Implementation ================== */}\par
00426 Semaphore::Semaphore(uint8_t initial_count, uint8_t max_count) : count(initial_count), max_count(max_count) \{\}\par
00427 \par
00428 {\cf18 bool} Semaphore::wait(uint8_t task_id)\par
00429 \{\par
00430     (void)task_id;  {\cf20 // Unused parameter}\par
00431     ATOMIC_BLOCK(ATOMIC_RESTORESTATE)\par
00432     \{\par
00433         {\cf19 if} (count > 0)\par
00434         \{\par
00435             count--;\par
00436             {\cf19 return} {\cf17 true};\par
00437         \}\par
00438     \}\par
00439     {\cf19 return} {\cf17 false};\par
00440 \}\par
00441 \par
00442 {\cf18 void} Semaphore::signal()\par
00443 \{\par
00444     ATOMIC_BLOCK(ATOMIC_RESTORESTATE)\par
00445     \{\par
00446         {\cf19 if} (count < max_count)\par
00447         \{\par
00448             count++;\par
00449         \}\par
00450     \}\par
00451 \}\par
00452 \par
00453 uint8_t Semaphore::getCount(){\cf17  const }\{ {\cf19 return} count; \}\par
00454 \par
00455 uint8_t Semaphore::getMaxCount(){\cf17  const }\{ {\cf19 return} max_count; \}\par
00456 \par
00457 {\cf20 /* ================== Task Implementation ================== */}\par
00458 {\cf20 // Initialize static counter}\par
00459 uint16_t Task::createdInstanceCount = 0;\par
00460 Task::Task({\cf17 const} __FlashStringHelper *task_name)\par
00461     : remainingTime(0),\par
00462       periodMs(DEFAULT_TASK_PERIOD),\par
00463       taskId(0),\par
00464       stateAndPriority(PRIORITY_NORMAL << 4), {\cf20 // INACTIVE state, PRIORITY_NORMAL priority}\par
00465       name(task_name)\par
00466 \{\par
00467     {\cf20 // Bitfield is already initialized to 0}\par
00468     createdInstanceCount++;\par
00469 \}\par
00470 \par
00471 Task::~Task()\par
00472 \{\par
00473     {\cf19 if} (createdInstanceCount > 0)\par
00474     \{\par
00475         createdInstanceCount--;\par
00476     \}\par
00477 \}\par
00478 \par
00479 {\cf18 void} Task::start()\par
00480 \{\par
00481     {\cf19 if} (getState() == INACTIVE)\par
00482     \{\par
00483         setState(ACTIVE);\par
00484         remainingTime = periodMs;\par
00485         on_start();\par
00486     \}\par
00487 \}\par
00488 \par
00489 {\cf18 void} Task::stop()\par
00490 \{\par
00491     {\cf19 if} (getState() == ACTIVE || getState() == SUSPENDED)\par
00492     \{\par
00493         setState(INACTIVE);\par
00494         on_stop();\par
00495     \}\par
00496 \}\par
00497 \par
00498 {\cf18 void} Task::suspend()\par
00499 \{\par
00500     {\cf19 if} (getState() == ACTIVE)\par
00501     \{\par
00502         setState(SUSPENDED);\par
00503     \}\par
00504 \}\par
00505 \par
00506 {\cf18 void} Task::resume()\par
00507 \{\par
00508     {\cf19 if} (getState() == SUSPENDED)\par
00509     \{\par
00510         setState(ACTIVE);\par
00511         remainingTime = periodMs;\par
00512     \}\par
00513 \}\par
00514 \par
00515 {\cf18 void} Task::terminate() \{ setState(TERMINATED); \}\par
00516 \par
00517 {\cf18 void} Task::setPeriod(uint16_t period)\par
00518 \{\par
00519     periodMs = (period < MIN_TASK_PERIOD) ? MIN_TASK_PERIOD : ((period > MAX_TASK_PERIOD) ? MAX_TASK_PERIOD : period);\par
00520 \}\par
00521 \par
00522 uint16_t Task::getPeriod(){\cf17  const }\{ {\cf19 return} periodMs; \}\par
00523 \par
00524 {\cf18 void} Task::setPriority(Priority priority) \{ stateAndPriority = (stateAndPriority & 0x0F) | (({\cf17 static_cast<}uint8_t{\cf17 >}(priority) & 0x0F) << 4); \}\par
00525 \par
00526 {\cf18 void} Task::setPriority(uint8_t prio) \{ stateAndPriority = (stateAndPriority & 0x0F) | ((prio & 0x0F) << 4); \}\par
00527 \par
00528 uint8_t Task::getPriority(){\cf17  const }\{ {\cf19 return} (stateAndPriority >> 4) & 0x0F; \}\par
00529 \par
00530 {\cf18 void} Task::setMaxMessageBudget(uint8_t budget)\par
00531 \{\par
00532     maxMessageBudget = budget;\par
00533 \}\par
00534 \par
00535 \par
00536 Task::State Task::getState(){\cf17  const }\{ {\cf19 return} {\cf17 static_cast<}State{\cf17 >}(stateAndPriority & 0x0F); \}\par
00537 \par
00538 {\cf18 void} Task::setState(State newState) \{ stateAndPriority = (stateAndPriority & 0xF0) | {\cf17 static_cast<}uint8_t{\cf17 >}(newState); \}\par
00539 \par
00540 {\cf18 bool} Task::checkState(State expected){\cf17  const }\{ {\cf19 return} getState() == expected; \}\par
00541 \par
00542 {\cf18 bool} Task::isActive(){\cf17  const }\{ {\cf19 return} getState() == ACTIVE; \}\par
00543 \par
00544 {\cf18 bool} Task::isInactive(){\cf17  const }\{ {\cf19 return} getState() == INACTIVE; \}\par
00545 \par
00546 uint8_t Task::getId(){\cf17  const }\{ {\cf19 return} taskId; \}\par
00547 \par
00548 {\cf17 const} __FlashStringHelper *Task::getName(){\cf17  const }\{ {\cf19 return} name; \}\par
00549 \par
00550 {\cf18 void} Task::setName({\cf17 const} __FlashStringHelper *task_name) \{ name = task_name; \}\par
00551 \par
00552 {\cf20 // Subscribe/unsubscribe methods are now inline in header file}\par
00553 \par
00554 {\cf18 void} Task::publish(uint8_t topic, uint8_t type, uint16_t arg)\par
00555 \{\par
00556     OS.publishMessage(topic, type, arg);\par
00557 \}\par
00558 \par
00559 {\cf18 void} Task::tell(uint8_t target_task_id, uint8_t type, uint16_t arg)\par
00560 \{\par
00561     OS.sendMessage(target_task_id, type, arg);\par
00562 \}\par
00563 \par
00564 {\cf18 void} Task::log({\cf17 const} __FlashStringHelper *msg) \{ OS.logMessage({\cf17 this}, Scheduler::LOG_INFO, msg); \}\par
00565 \par
00566 {\cf18 void} Task::logDebug({\cf17 const} __FlashStringHelper *msg) \{ OS.logMessage({\cf17 this}, Scheduler::LOG_DEBUG, msg); \}\par
00567 \par
00568 {\cf18 void} Task::logInfo({\cf17 const} __FlashStringHelper *msg) \{ OS.logMessage({\cf17 this}, Scheduler::LOG_INFO, msg); \}\par
00569 \par
00570 {\cf18 void} Task::logWarn({\cf17 const} __FlashStringHelper *msg) \{ OS.logMessage({\cf17 this}, Scheduler::LOG_WARN, msg); \}\par
00571 \par
00572 {\cf18 void} Task::logError({\cf17 const} __FlashStringHelper *msg) \{ OS.logMessage({\cf17 this}, Scheduler::LOG_ERROR, msg); \}\par
00573 \par
00574 {\cf17 template} <{\cf17 typename} T>\par
00575 T Task::createTimerTyped(uint32_t duration_ms){\cf17  const}\par
00576 {\cf17 }\{\par
00577     T timer;\par
00578     {\cf20 // Extract the underlying type from TimerT<T>}\par
00579     {\cf17 using }UnderlyingType = {\cf17 decltype}(timer.durationMs);\par
00580     UnderlyingType max_duration = {\cf17 static_cast<}UnderlyingType{\cf17 >}(~static_cast<UnderlyingType>(0));\par
00581     UnderlyingType safe_duration =\par
00582         (duration_ms > max_duration) ? max_duration : {\cf17 static_cast<}UnderlyingType{\cf17 >}(duration_ms);\par
00583     timer.startTimer(safe_duration);\par
00584     {\cf19 return} timer;\par
00585 \}\par
00586 \par
00587 {\cf20 // Explicit template instantiations for Task::createTimerTyped}\par
00588 {\cf17 template} Timer8 Task::createTimerTyped<Timer8>(uint32_t) {\cf17 const};\par
00589 {\cf17 template} Timer16 Task::createTimerTyped<Timer16>(uint32_t) {\cf17 const};\par
00590 {\cf17 template} Timer32 Task::createTimerTyped<Timer32>(uint32_t) {\cf17 const};\par
00591 \par
00592 {\cf18 void} Task::processMessages()\par
00593 \{\par
00594     {\cf20 // Message processing removed for RAM optimization}\par
00595     {\cf20 // Messages are now handled directly by the scheduler}\par
00596 \}\par
00597 \par
00598 {\cf20 // Task timing monitoring methods}\par
00599 uint16_t Task::getDelayCount(){\cf17  const}\par
00600 {\cf17 }\{\par
00601     {\cf19 return} delayCount;\par
00602 \}\par
00603 \par
00604 uint16_t Task::getMaxDelay(){\cf17  const}\par
00605 {\cf17 }\{\par
00606     {\cf19 return} maxDelayMs;\par
00607 \}\par
00608 \par
00609 uint32_t Task::getScheduledTime(){\cf17  const}\par
00610 {\cf17 }\{\par
00611     {\cf19 return} scheduledTime;\par
00612 \}\par
00613 \par
00614 uint32_t Task::getActualStartTime(){\cf17  const}\par
00615 {\cf17 }\{\par
00616     {\cf19 return} actualStartTime;\par
00617 \}\par
00618 \par
00619 {\cf20 /* ================== Scheduler Implementation ================== */}\par
00620 Scheduler::Scheduler()\par
00621     : taskCount(0),\par
00622       nextTaskId(1),\par
00623       systemTime(0),\par
00624       running(false),\par
00625       currentLogLevel(LOG_INFO)\par
00626 \{\par
00627     {\cf20 // Initialize linked list pointers}\par
00628     taskHead = {\cf17 nullptr};\par
00629     taskTail = {\cf17 nullptr};\par
00630 \}\par
00631 {\cf20 // ========== Stack Canary (AVR only) ==========}\par
00632 {\cf21 #if defined(__AVR__)}\par
00633 {\cf20 // Canary byte used to mark free RAM for stack usage measurement}\par
00634 {\cf17 static} {\cf17 const} uint8_t STACK_CANARY_BYTE = 0xCD;\par
00635 \par
00636 {\cf20 // Pointers delimiting the canary region. We avoid touching the current stack.}\par
00637 {\cf17 static} uint8_t *g_canary_start = {\cf17 nullptr};\par
00638 {\cf17 static} uint8_t *g_canary_end   = {\cf17 nullptr};\par
00639 \par
00645 {\cf17 static} {\cf18 void} init_stack_canary()\par
00646 \{\par
00647     {\cf17 extern} {\cf18 char} __bss_end;\par
00648     {\cf17 extern} {\cf18 char} *__brkval;\par
00649     {\cf20 // Current stack pointer approximation via address of a local}\par
00650     uint8_t sp_probe;\par
00651     uint8_t *sp = (uint8_t *)&sp_probe;\par
00652 \par
00653     {\cf20 // Compute heap top}\par
00654     uint8_t *heap_top = (uint8_t *)(__brkval ? __brkval : &__bss_end);\par
00655 \par
00656     {\cf20 // Safety margin to keep above the canary (below SP)}\par
00657 {\cf21 #ifndef FSMOS_STACK_CANARY_MARGIN}\par
00658 {\cf21 #define FSMOS_STACK_CANARY_MARGIN 32}\par
00659 {\cf21 #endif}\par
00660 \par
00661     {\cf20 // Region end just below current SP}\par
00662     uint8_t *region_end = sp - FSMOS_STACK_CANARY_MARGIN;\par
00663 \par
00664     {\cf20 // Start from heap top - cover entire free RAM area}\par
00665     uint8_t *region_start = heap_top;\par
00666 \par
00667     {\cf19 if} (region_start >= region_end)\par
00668     \{\par
00669         {\cf20 // Nothing to initialize; leave pointers null}\par
00670         g_canary_start = g_canary_end = {\cf17 nullptr};\par
00671         {\cf19 return};\par
00672     \}\par
00673 \par
00674     g_canary_start = region_start;\par
00675     g_canary_end   = region_end;\par
00676 \par
00677     {\cf20 // Disable interrupts around the fill to keep ISR stacks from interfering}\par
00678     uint8_t sreg = SREG;\par
00679     cli();\par
00680     {\cf19 for} (uint8_t *p = g_canary_start; p <= g_canary_end; ++p)\par
00681     \{\par
00682         *p = STACK_CANARY_BYTE;\par
00683     \}\par
00684     SREG = sreg; {\cf20 // restore interrupt state}\par
00685 \}\par
00686 \par
00687 {\cf17 static} uint16_t measure_stack_used()\par
00688 \{\par
00689     {\cf19 if} (!g_canary_start || !g_canary_end || g_canary_start > g_canary_end)\par
00690     \{\par
00691         {\cf19 return} 0;\par
00692     \}\par
00693     uint8_t *p = g_canary_start;\par
00694     {\cf19 while} (p <= g_canary_end && *p == STACK_CANARY_BYTE)\par
00695     \{\par
00696         ++p;\par
00697     \}\par
00698     {\cf19 if} (p > g_canary_end)\par
00699     \{\par
00700         {\cf19 return} 0;\par
00701     \}\par
00702     {\cf20 // Bytes from first non-canary up to end are considered used}\par
00703     {\cf19 return} (uint16_t)(g_canary_end - p + 1);\par
00704 \}\par
00705 {\cf21 #endif}\par
00706 \par
00707 Scheduler::~Scheduler() \{ removeAll(); \}\par
00708 \par
00709 {\cf20 // Missing method implementations}\par
00710 TaskNode *Scheduler::acquireTaskNode(Task *task)\par
00711 \{\par
00712     {\cf19 return} allocateTaskNode(task);\par
00713 \}\par
00714 \par
00715 {\cf18 void} Scheduler::releaseTaskNode(TaskNode *node)\par
00716 \{\par
00717     deallocateTaskNode(node);\par
00718 \}\par
00719 \par
00720 {\cf18 bool} Scheduler::dequeueQueuedMessageNode(MsgNode *&outNode)\par
00721 \{\par
00722     {\cf20 // This method should work with the main message queue, not a separate queued message queue}\par
00723     {\cf19 if} (!msgHead)\par
00724     \{\par
00725         outNode = {\cf17 nullptr};\par
00726         {\cf19 return} {\cf17 false};\par
00727     \}\par
00728 \par
00729     outNode = msgHead;\par
00730     msgHead = msgHead->next;\par
00731 \par
00732     {\cf19 if} (!msgHead)\par
00733     \{\par
00734         msgTail = {\cf17 nullptr};\par
00735     \}\par
00736 \par
00737     outNode->next = {\cf17 nullptr};\par
00738     msgCount--;\par
00739     {\cf19 return} {\cf17 true};\par
00740 \}\par
00741 \par
00742 {\cf18 bool} Scheduler::initializeTaskNodePool()\par
00743 \{\par
00744     {\cf19 if} (taskNodePoolInitialized)\par
00745     \{\par
00746         {\cf19 return} {\cf17 true};\par
00747     \}\par
00748     {\cf20 // Preallocate TaskNode objects as a singly-linked free-list.}\par
00749     {\cf20 // Start with the number of created tasks (at least 1).}\par
00750     TaskNode *prev = {\cf17 nullptr};\par
00751     uint16_t initial = Task::getCreatedInstanceCount();\par
00752     {\cf19 if} (initial == 0)\par
00753     \{\par
00754         initial = 1;\par
00755     \}\par
00756     {\cf19 for} (uint8_t i = 0; i < initial; ++i)\par
00757     \{\par
00758         TaskNode *node = (TaskNode *)malloc({\cf17 sizeof}(TaskNode));\par
00759         {\cf19 if} (!node)\par
00760         \{\par
00761             {\cf20 // Allocation failure; cleanup any already allocated nodes}\par
00762             {\cf19 while} (prev)\par
00763             \{\par
00764                 TaskNode *temp = prev;\par
00765                 prev = prev->next;\par
00766                 free(temp);\par
00767             \}\par
00768             taskNodePoolCapacity = 0;\par
00769             {\cf19 return} {\cf17 false};\par
00770         \}\par
00771         {\cf20 // Initialize fields manually; building free-list in reverse}\par
00772         node->task = {\cf17 nullptr};\par
00773         node->next = prev;\par
00774         prev = node;\par
00775         taskNodePoolCapacity++;\par
00776     \}\par
00777     freeTaskNodeHead = prev;\par
00778     taskNodePoolInitialized = {\cf17 true};\par
00779     {\cf19 return} {\cf17 true};\par
00780 \}\par
00781 \par
00782 \par
00783 {\cf18 bool} Scheduler::add(Task *task)\par
00784 \{\par
00785     {\cf19 if} (!task)\par
00786     \{\par
00787         {\cf19 return} {\cf17 false};\par
00788     \}\par
00789 \par
00790     {\cf20 // Check task limit based on TOPIC_BITFIELD_SIZE}\par
00791     {\cf19 if} (taskCount >= MAX_TOPICS)\par
00792     \{\par
00793         logSystemEvent(LOG_ERROR, F({\cf22 "Task limit reached"}));\par
00794         logInfof(F({\cf22 "Max tasks: %u, Current: %u"}), MAX_TOPICS, taskCount);\par
00795         {\cf19 return} {\cf17 false};\par
00796     \}\par
00797 \par
00798     {\cf20 // Acquire node from pool using helper method}\par
00799     TaskNode *newNode = allocateTaskNode(task);\par
00800     {\cf19 if} (!newNode)\par
00801     \{\par
00802         {\cf19 return} {\cf17 false};  {\cf20 // Pool allocation failed}\par
00803     \}\par
00804 \par
00805     {\cf20 // Assign task ID}\par
00806     task->taskId = nextTaskId++;\par
00807     {\cf19 if} (nextTaskId == 0)\par
00808     \{\par
00809         nextTaskId = 1;    {\cf20 // Avoid zero task ID}\par
00810     \}\par
00811 \par
00812     {\cf20 // Add to linked list (singly-linked)}\par
00813     {\cf19 if} (taskHead == {\cf17 nullptr})\par
00814     \{\par
00815         {\cf20 // First task}\par
00816         taskHead = taskTail = newNode;\par
00817     \}\par
00818     {\cf19 else}\par
00819     \{\par
00820         {\cf20 // Append to tail}\par
00821         taskTail->next = newNode;\par
00822         taskTail = newNode;\par
00823     \}\par
00824 \par
00825     taskCount++;\par
00826     {\cf19 return} {\cf17 true};\par
00827 \}\par
00828 \par
00829 {\cf18 bool} Scheduler::remove(Task *task)\par
00830 \{\par
00831     {\cf19 if} (!task)\par
00832     \{\par
00833         {\cf19 return} {\cf17 false};\par
00834     \}\par
00835 \par
00836     {\cf20 // Find the node containing this task, tracking previous (singly-linked)}\par
00837     TaskNode *current = taskHead;\par
00838     TaskNode *previous = {\cf17 nullptr};\par
00839     {\cf19 while} (current != {\cf17 nullptr})\par
00840     \{\par
00841         {\cf19 if} (current->task == task)\par
00842         \{\par
00843             {\cf20 // Remove from linked list}\par
00844             {\cf19 if} (previous)\par
00845             \{\par
00846                 previous->next = current->next;\par
00847             \}\par
00848             {\cf19 else}\par
00849             \{\par
00850                 {\cf20 // Removing head}\par
00851                 taskHead = current->next;\par
00852             \}\par
00853 \par
00854             {\cf19 if} (current == taskTail)\par
00855             \{\par
00856                 {\cf20 // Update tail if needed}\par
00857                 taskTail = previous;\par
00858             \}\par
00859 \par
00860             deallocateTaskNode(current);\par
00861             taskCount--;\par
00862             {\cf19 return} {\cf17 true};\par
00863         \}\par
00864         previous = current;\par
00865         current = current->next;\par
00866     \}\par
00867 \par
00868     {\cf19 return} {\cf17 false};\par
00869 \}\par
00870 \par
00871 {\cf18 void} Scheduler::removeAll()\par
00872 \{\par
00873     TaskNode *current = taskHead;\par
00874     {\cf19 while} (current != {\cf17 nullptr})\par
00875     \{\par
00876         TaskNode *next = current->next;\par
00877         current->task->stop();\par
00878         deallocateTaskNode(current);\par
00879         current = next;\par
00880     \}\par
00881     taskHead = taskTail = {\cf17 nullptr};\par
00882     taskCount = 0;\par
00883 \}\par
00884 \par
00885 Task *Scheduler::getTask(uint8_t task_id)\par
00886 \{\par
00887     {\cf19 return} findTask([task_id](Task * task) \{ {\cf19 return} task->getId() == task_id; \});\par
00888 \}\par
00889 \par
00890 {\cf20 // getTaskCount is now inline in header file}\par
00891 \par
00892 uint16_t Scheduler::getMaxTasks(){\cf17  const }\{ {\cf19 return} taskNodePoolCapacity; \}\par
00893 \par
00894 {\cf18 void} Scheduler::begin()\par
00895 \{\par
00896     {\cf20 // Initialize stack canary before tasks start executing}\par
00897 {\cf21 #if defined(__AVR__)}\par
00898     init_stack_canary();\par
00899 {\cf21 #endif}\par
00900     {\cf20 // Set log level to INFO for better debugging}\par
00901     setLogLevel(LOG_INFO);\par
00902 \par
00903     {\cf20 // Log startup message}\par
00904     logSystemEvent(LOG_INFO, F({\cf22 "FsmOS starting"}));\par
00905 \par
00906     running = {\cf17 true};\par
00907     systemTime = millis();\par
00908 \par
00909 {\cf21 #if defined(__AVR__)}\par
00910     init_stdio_to_serial();\par
00911 {\cf21 #endif}\par
00912 \par
00913     {\cf20 // Start all tasks}\par
00914     forEachTask([{\cf17 this}](Task * task)\par
00915     \{\par
00916         task->start();\par
00917         feedWatchdog();\par
00918     \});\par
00919 \par
00920     {\cf20 // Log task count}\par
00921     logSystemEvent(LOG_INFO, F({\cf22 "Scheduler ready"}));\par
00922 \}\par
00923 \par
00924 {\cf18 void} Scheduler::loopOnce()\par
00925 \{\par
00926     {\cf19 if} (!running)\par
00927     \{\par
00928         {\cf19 return};\par
00929     \}\par
00930 \par
00931     updateSystemTime();\par
00932 \par
00933     {\cf20 // Decrease remaining time for all active tasks}\par
00934     forEachTask([](Task * task)\par
00935     \{\par
00936         {\cf19 if} (task->isActive() && task->remainingTime > 0)\par
00937         \{\par
00938             task->remainingTime--;\par
00939         \}\par
00940     \});\par
00941 \par
00942     {\cf20 // Feed watchdog timer}\par
00943     feedWatchdog();\par
00944 \par
00945     {\cf20 // Process a limited number of queued messages per tick}\par
00946     processMessages();\par
00947 \par
00948     Task *next_task = findNextTask();\par
00949     {\cf19 if} (next_task)\par
00950     \{\par
00951         executeTask(next_task);\par
00952     \}\par
00953 \}\par
00954 \par
00955 {\cf18 void} Scheduler::loop()\par
00956 \{\par
00957     {\cf19 while} (running)\par
00958     \{\par
00959         loopOnce();\par
00960     \}\par
00961 \}\par
00962 \par
00963 {\cf18 void} Scheduler::stop() \{ running = {\cf17 false}; \}\par
00964 \par
00965 {\cf18 void} Scheduler::publishMessage(uint8_t topic, uint8_t type, uint16_t arg)\par
00966 \{\par
00967     {\cf20 // Enqueue for all subscribed tasks}\par
00968     forEachTask([{\cf17 this}, topic, type, arg](Task * task)\par
00969     \{\par
00970         {\cf19 if} (task->isActive() && task->isSubscribedToTopic(topic))\par
00971         \{\par
00972             enqueueQueuedMessage(task->getId(), topic, type, arg);\par
00973         \}\par
00974     \});\par
00975 \}\par
00976 \par
00977 {\cf18 void} Scheduler::sendMessage(uint8_t task_id, uint8_t type, uint16_t arg)\par
00978 \{\par
00979     Task *target_task = getTask(task_id);\par
00980     {\cf19 if} (!target_task || !target_task->isActive())\par
00981     \{\par
00982         {\cf19 return};\par
00983     \}\par
00984 \par
00985     enqueueQueuedMessage(task_id, 0, type, arg);\par
00986 \}\par
00987 \par
00988 uint32_t Scheduler::now(){\cf17  const }\{ {\cf19 return} systemTime; \}\par
00989 \par
00990 uint16_t Scheduler::getFreeMemory(){\cf17  const}\par
00991 {\cf17 }\{\par
00992     {\cf17 extern} {\cf18 char} __heap_start;      {\cf20 // start of heap (in .bss)}\par
00993     {\cf17 extern} {\cf18 char} *__brkval;         {\cf20 // current heap break (nullptr if none)}\par
00994     {\cf18 char} v;                        {\cf20 // stack variable to get current stack address}\par
00995     {\cf20 // Difference between current stack pointer and heap end/start}\par
00996     {\cf19 return} (uint16_t)(&v - (__brkval == 0 ? &__heap_start : __brkval));\par
00997 \}\par
00998 \par
00999 {\cf18 void} Scheduler::setLogLevel(LogLevel level) \{ currentLogLevel = level; \}\par
01000 \par
01001 {\cf18 void} Scheduler::logMessage(Task *task, LogLevel level, {\cf17 const} {\cf18 char} *msg)\par
01002 \{\par
01003     {\cf19 if} (level < currentLogLevel)\par
01004     \{\par
01005         {\cf19 return};\par
01006     \}\par
01007 \par
01008     {\cf17 const} {\cf18 char} *level_str = {\cf22 "DEBUG"};\par
01009     {\cf19 switch} (level)\par
01010     \{\par
01011         {\cf19 case} LOG_INFO:\par
01012             level_str = {\cf22 "INFO"};\par
01013             {\cf19 break};\par
01014         {\cf19 case} LOG_WARN:\par
01015             level_str = {\cf22 "WARN"};\par
01016             {\cf19 break};\par
01017         {\cf19 case} LOG_ERROR:\par
01018             level_str = {\cf22 "ERROR"};\par
01019             {\cf19 break};\par
01020         {\cf19 default}:\par
01021             {\cf19 break};\par
01022     \}\par
01023 \par
01024     Serial.print(F({\cf22 "["}));\par
01025     Serial.print(level_str);\par
01026     Serial.print(F({\cf22 "] "}));\par
01027 \par
01028     {\cf19 if} (task)\par
01029     \{\par
01030         Serial.print(F({\cf22 "T"}));\par
01031         Serial.print(task->getId());\par
01032         Serial.print(F({\cf22 ": "}));\par
01033     \}\par
01034 \par
01035     Serial.println(msg);\par
01036 \}\par
01037 \par
01038 {\cf18 void} Scheduler::logMessage(Task *task, LogLevel level, {\cf17 const} __FlashStringHelper *msg)\par
01039 \{\par
01040     {\cf19 if} (level < currentLogLevel)\par
01041     \{\par
01042         {\cf19 return};\par
01043     \}\par
01044 \par
01045     {\cf17 const} {\cf18 char} *level_str = {\cf22 "DEBUG"};\par
01046     {\cf19 switch} (level)\par
01047     \{\par
01048         {\cf19 case} LOG_INFO:\par
01049             level_str = {\cf22 "INFO"};\par
01050             {\cf19 break};\par
01051         {\cf19 case} LOG_WARN:\par
01052             level_str = {\cf22 "WARN"};\par
01053             {\cf19 break};\par
01054         {\cf19 case} LOG_ERROR:\par
01055             level_str = {\cf22 "ERROR"};\par
01056             {\cf19 break};\par
01057         {\cf19 default}:\par
01058             {\cf19 break};\par
01059     \}\par
01060 \par
01061     Serial.print(F({\cf22 "["}));\par
01062     Serial.print(level_str);\par
01063     Serial.print(F({\cf22 "] "}));\par
01064 \par
01065     {\cf19 if} (task)\par
01066     \{\par
01067         Serial.print(F({\cf22 "T"}));\par
01068         Serial.print(task->getId());\par
01069         Serial.print(F({\cf22 ": "}));\par
01070     \}\par
01071 \par
01072     Serial.println(msg);\par
01073 \}\par
01074 \par
01075 {\cf18 void} Scheduler::onTick() \{ systemTime++; \}\par
01076 \par
01077 {\cf18 void} Scheduler::processMessages()\par
01078 \{\par
01079     {\cf19 while} ({\cf17 true})\par
01080     \{\par
01081         {\cf20 // Dequeue node to ensure we recycle only after handler finishes}\par
01082         {\cf19 if} (msgCount == 0)\par
01083         \{\par
01084             {\cf19 break};\par
01085         \}\par
01086         MsgNode *node = msgHead;\par
01087         msgHead = node->next;\par
01088         {\cf19 if} (!msgHead)\par
01089         \{\par
01090             msgTail = {\cf17 nullptr};\par
01091         \}\par
01092         msgCount--;\par
01093 \par
01094         QueuedMessage &qm = node->payload;\par
01095         Task *target = getTask(qm.targetTaskId);\par
01096         {\cf19 if} (target && target->isActive())\par
01097         \{\par
01098             target->on_msg(qm.msg);\par
01099         \}\par
01100 \par
01101         {\cf20 // Recycle node after handler returns; keep buffer for reuse}\par
01102         node->next = freeHead;\par
01103         freeHead = node;\par
01104     \}\par
01105 \}\par
01106 \par
01107 {\cf18 void} Scheduler::updateSystemTime() \{ systemTime = millis(); \}\par
01108 \par
01109 Task *Scheduler::findNextTask()\par
01110 \{\par
01111     Task *nextTask = {\cf17 nullptr};\par
01112     uint16_t shortestTime = UINT16_MAX;\par
01113 \par
01114     TaskNode *current = taskHead;\par
01115     {\cf19 while} (current != {\cf17 nullptr})\par
01116     \{\par
01117         {\cf19 if} (current->task && current->task->isActive() && current->task->remainingTime == 0)\par
01118         \{\par
01119             {\cf20 // If task declares a message production budget, ensure enough free queue slots}\par
01120             uint8_t budget = current->task->getMaxMessageBudget();\par
01121             {\cf20 // Only use default if task hasn't explicitly set a budget (inherited default)}\par
01122             {\cf19 if} (budget == DEFAULT_TASK_MESSAGE_BUDGET)\par
01123             \{\par
01124                 {\cf20 // Task is using the default, which is fine}\par
01125             \}\par
01126             {\cf20 // If budget is 0, task explicitly wants no message production}\par
01127             {\cf20 // If budget > 0, task has explicit budget}\par
01128             {\cf20 // In both cases, respect the task's decision}\par
01129             {\cf19 if} (getFreeQueueSlots() < budget)\par
01130             \{\par
01131                 {\cf20 // Skip this task for now; not enough capacity to accept its messages}\par
01132             \}\par
01133             {\cf19 else} {\cf19 if} (nextTask == {\cf17 nullptr})\par
01134             \{\par
01135                 nextTask = current->task;\par
01136             \}\par
01137             {\cf19 else} {\cf19 if} (current->task->getPriority() > nextTask->getPriority())\par
01138             \{\par
01139                 {\cf20 // Higher enum value wins (PRIORITY_SYSTEM=7 > PRIORITY_LOWEST=0)}\par
01140                 nextTask = current->task;\par
01141             \}\par
01142             {\cf19 else} {\cf19 if} (current->task->getPriority() == nextTask->getPriority())\par
01143             \{\par
01144                 {\cf20 // Same priority, smaller task ID wins}\par
01145                 {\cf19 if} (current->task->getId() < nextTask->getId())\par
01146                 \{\par
01147                     nextTask = current->task;\par
01148                 \}\par
01149             \}\par
01150         \}\par
01151         {\cf19 else} {\cf19 if} (current->task && current->task->isActive() && current->task->remainingTime < shortestTime)\par
01152         \{\par
01153             shortestTime = current->task->remainingTime;\par
01154         \}\par
01155         current = current->next;\par
01156     \}\par
01157 \par
01158     {\cf19 return} nextTask;\par
01159 \}\par
01160 \par
01161 {\cf18 void} Scheduler::executeTask(Task *task)\par
01162 \{\par
01163     {\cf19 if} (!task || !task->isActive())\par
01164     \{\par
01165         {\cf19 return};\par
01166     \}\par
01167 \par
01168     uint32_t execStart = micros();\par
01169     uint32_t currentTime = systemTime;\par
01170 \par
01171     {\cf20 // Handle task timing monitoring}\par
01172     handleTaskTiming(task, currentTime);\par
01173 \par
01174     {\cf20 // Execute the actual task step}\par
01175     executeTaskStep(task);\par
01176 \par
01177     {\cf20 // Update task execution statistics}\par
01178     updateTaskStatistics(task, execStart);\par
01179 \par
01180     {\cf20 // Update timing monitoring variables}\par
01181     updateTimingVariables(task);\par
01182 \par
01183     {\cf20 // Check for terminated tasks}\par
01184     checkForTerminatedTask(task);\par
01185 \}\par
01186 \par
01187 {\cf20 // Refactored helper methods for executeTask}\par
01188 {\cf18 void} Scheduler::handleTaskTiming(Task *task, uint32_t currentTime)\par
01189 \{\par
01190     {\cf20 // Set scheduled time (when task should have started)}\par
01191     task->scheduledTime = currentTime - task->getPeriod();\par
01192     task->actualStartTime = currentTime;\par
01193 \par
01194     {\cf20 // Check for delay}\par
01195     {\cf19 if} (task->actualStartTime > task->scheduledTime)\par
01196     \{\par
01197         uint32_t delay = task->actualStartTime - task->scheduledTime;\par
01198         uint16_t delayMs = (delay > 65535) ? 65535 : {\cf17 static_cast<}uint16_t{\cf17 >}(delay);\par
01199 \par
01200         {\cf20 // Update delay statistics}\par
01201         task->delayCount++;\par
01202         {\cf19 if} (delayMs > task->maxDelayMs)\par
01203         \{\par
01204             task->maxDelayMs = delayMs;\par
01205         \}\par
01206 \par
01207         {\cf20 // Log delay with attribution}\par
01208         logTaskDelay(task, delayMs, lastExecutedTaskId);\par
01209     \}\par
01210 \}\par
01211 \par
01212 {\cf18 void} Scheduler::executeTaskStep(Task *task)\par
01213 \{\par
01214     {\cf20 // Reset remaining time for next execution}\par
01215     task->remainingTime = task->getPeriod();\par
01216 \par
01217     {\cf20 // Execute task step}\par
01218     task->step();\par
01219 \}\par
01220 \par
01221 {\cf18 void} Scheduler::updateTaskStatistics(Task *task, uint32_t execStart)\par
01222 \{\par
01223     {\cf20 // Calculate execution time}\par
01224     uint32_t execTime = micros() - execStart;\par
01225     uint16_t execTime16 = (execTime > 65535) ? 65535 : {\cf17 static_cast<}uint16_t{\cf17 >}(execTime);\par
01226 \par
01227     {\cf20 // Update run count}\par
01228     {\cf19 if} (task->runCount < 65535)\par
01229     \{\par
01230         task->runCount++;\par
01231     \}\par
01232 \par
01233     {\cf20 // Update max execution time}\par
01234     {\cf19 if} (execTime16 > task->maxExecTimeUs)\par
01235     \{\par
01236         task->maxExecTimeUs = execTime16;\par
01237     \}\par
01238 \par
01239     {\cf20 // Update average execution time}\par
01240     {\cf19 if} (task->runCount == 1)\par
01241     \{\par
01242         task->avgExecTimeUs = execTime16;\par
01243     \}\par
01244     {\cf19 else} {\cf19 if} (task->runCount == 65535)\par
01245     \{\par
01246         {\cf20 // Exponential moving average to avoid overflow}\par
01247         uint32_t diff = execTime16 - task->avgExecTimeUs;\par
01248         int32_t adjustment = diff / 1000;  {\cf20 // Slow adaptation}\par
01249         int32_t newAvg = task->avgExecTimeUs + adjustment;\par
01250 \par
01251         {\cf20 // Clamp to valid range}\par
01252         {\cf19 if} (newAvg < 0)\par
01253         \{\par
01254             newAvg = 0;\par
01255         \}\par
01256         {\cf19 if} (newAvg > 65535)\par
01257         \{\par
01258             newAvg = 65535;\par
01259         \}\par
01260 \par
01261         task->avgExecTimeUs = {\cf17 static_cast<}uint16_t{\cf17 >}(newAvg);\par
01262     \}\par
01263     {\cf19 else}\par
01264     \{\par
01265         {\cf20 // Simple moving average}\par
01266         uint32_t newAvg = ((uint32_t)task->avgExecTimeUs * (task->runCount - 1) + execTime16) / task->runCount;\par
01267         task->avgExecTimeUs = (newAvg > 65535) ? 65535 : {\cf17 static_cast<}uint16_t{\cf17 >}(newAvg);\par
01268     \}\par
01269 \}\par
01270 \par
01271 {\cf18 void} Scheduler::updateTimingVariables(Task *task)\par
01272 \{\par
01273     lastExecutedTaskId = task->getId();\par
01274     lastTaskEndTime = systemTime;\par
01275 \}\par
01276 \par
01277 {\cf18 void} Scheduler::checkForTerminatedTask(Task *task)\par
01278 \{\par
01279     {\cf19 if} (task->getState() == Task::TERMINATED)\par
01280     \{\par
01281         remove(task);\par
01282     \}\par
01283 \}\par
01284 \par
01285 {\cf18 void} Scheduler::logTaskDelay(Task *task, uint16_t delayMs, uint8_t causingTaskId)\par
01286 \{\par
01287     {\cf20 // Task delay logging disabled to save ROM}\par
01288     (void)task;\par
01289     (void)delayMs;\par
01290     (void)causingTaskId;\par
01291 \}\par
01292 \par
01293 {\cf20 // Task iteration template methods}\par
01294 {\cf17 template}<{\cf17 typename} Func>\par
01295 {\cf18 void} Scheduler::forEachTask(Func func)\par
01296 \{\par
01297     TaskNode *current = taskHead;\par
01298     {\cf19 while} (current != {\cf17 nullptr})\par
01299     \{\par
01300         {\cf19 if} (current->task)\par
01301         \{\par
01302             func(current->task);\par
01303         \}\par
01304         current = current->next;\par
01305     \}\par
01306 \}\par
01307 \par
01308 {\cf17 template}<{\cf17 typename} Func>\par
01309 Task *Scheduler::findTask(Func predicate)\par
01310 \{\par
01311     TaskNode *current = taskHead;\par
01312     {\cf19 while} (current != {\cf17 nullptr})\par
01313     \{\par
01314         {\cf19 if} (current->task && predicate(current->task))\par
01315         \{\par
01316             {\cf19 return} current->task;\par
01317         \}\par
01318         current = current->next;\par
01319     \}\par
01320     {\cf19 return} {\cf17 nullptr};\par
01321 \}\par
01322 \par
01323 {\cf20 // Explicit template instantiations for common use cases}\par
01324 {\cf17 template} {\cf18 void} Scheduler::forEachTask<void(*)(Task *)>({\cf18 void}(*)(Task *));\par
01325 {\cf17 template} Task *Scheduler::findTask<bool(*)(Task *)>({\cf18 bool}(*)(Task *));\par
01326 \par
01327 {\cf20 // Memory management helpers}\par
01328 TaskNode *Scheduler::allocateTaskNode(Task *task)\par
01329 \{\par
01330     {\cf19 if} (!taskNodePoolInitialized && !initializeTaskNodePool())\par
01331     \{\par
01332         {\cf19 return} {\cf17 nullptr};\par
01333     \}\par
01334     {\cf19 if} (!freeTaskNodeHead)\par
01335     \{\par
01336         {\cf20 // Try to expand by one}\par
01337         TaskNode *node = (TaskNode *)malloc({\cf17 sizeof}(TaskNode));\par
01338         {\cf19 if} (!node)\par
01339         \{\par
01340             {\cf19 return} {\cf17 nullptr};\par
01341         \}\par
01342         node->task = {\cf17 nullptr};\par
01343         node->next = {\cf17 nullptr};\par
01344         freeTaskNodeHead = node;\par
01345         taskNodePoolCapacity++;\par
01346     \}\par
01347     TaskNode *node = freeTaskNodeHead;\par
01348     freeTaskNodeHead = freeTaskNodeHead->next;\par
01349     node->task = task;\par
01350     node->next = {\cf17 nullptr};\par
01351     {\cf19 return} node;\par
01352 \}\par
01353 \par
01354 {\cf18 void} Scheduler::deallocateTaskNode(TaskNode *node)\par
01355 \{\par
01356     {\cf19 if} (!node)\par
01357     \{\par
01358         {\cf19 return};\par
01359     \}\par
01360     node->task = {\cf17 nullptr};\par
01361     node->next = freeTaskNodeHead;\par
01362     freeTaskNodeHead = node;\par
01363 \}\par
01364 \par
01365 Scheduler::MsgNode *Scheduler::allocateMsgNode()\par
01366 \{\par
01367     {\cf19 if} (!freeHead)\par
01368     \{\par
01369         {\cf19 if} (!allocateMsgNodesChunk())\par
01370         \{\par
01371             {\cf19 return} {\cf17 nullptr};\par
01372         \}\par
01373     \}\par
01374 \par
01375     MsgNode *node = freeHead;\par
01376     freeHead = freeHead->next;\par
01377     node->next = {\cf17 nullptr};\par
01378     {\cf19 return} node;\par
01379 \}\par
01380 \par
01381 {\cf18 void} Scheduler::deallocateMsgNode(Scheduler::MsgNode *node)\par
01382 \{\par
01383     {\cf19 if} (!node)\par
01384     \{\par
01385         {\cf19 return};\par
01386     \}\par
01387 \par
01388     {\cf20 // Free the buffer if it exists}\par
01389     {\cf19 if} (node->payload.buffer)\par
01390     \{\par
01391         free(node->payload.buffer);\par
01392         node->payload.buffer = {\cf17 nullptr};\par
01393         node->payload.capacity = 0;\par
01394     \}\par
01395 \par
01396     {\cf20 // Reset message data}\par
01397     node->payload.targetTaskId = 0;\par
01398     node->payload.msg.type = 0;\par
01399     node->payload.msg.topic = 0;\par
01400     node->payload.msg.arg = 0;\par
01401     node->payload.msg.refCount = 0;\par
01402 \par
01403     {\cf20 // Return to free list}\par
01404     node->next = freeHead;\par
01405     freeHead = node;\par
01406 \}\par
01407 \par
01408 {\cf20 // Logging system helpers}\par
01409 {\cf18 void} Scheduler::logSystemEvent(LogLevel level, {\cf17 const} __FlashStringHelper *msg)\par
01410 \{\par
01411     logMessage({\cf17 nullptr}, level, msg);\par
01412 \}\par
01413 \par
01414 {\cf18 void} Scheduler::logTaskExecution(Task *task, uint32_t execTime)\par
01415 \{\par
01416     {\cf20 // Execution time logging disabled to save ROM}\par
01417     (void)task;\par
01418     (void)execTime;\par
01419 \}\par
01420 \par
01421 {\cf20 /* ================== Additional Scheduler Methods ================== */}\par
01422 {\cf18 bool} Scheduler::getResetInfo(ResetInfo &info)\par
01423 \{\par
01424     {\cf20 // Basic reset info}\par
01425     info.resetReason = 0;\par
01426     info.resetTime = systemTime;\par
01427     info.watchdogTimeout = 0;\par
01428     info.lastTaskId = 0;\par
01429 \par
01430     {\cf20 // Get reset cause information}\par
01431     info.optibootResetFlags = getResetCauseFlags();\par
01432     info.optibootResetCause = getResetCause();\par
01433 \par
01434     {\cf19 return} {\cf17 true};\par
01435 \}\par
01436 \par
01437 ResetCause Scheduler::getResetCause()\par
01438 \{\par
01439     uint8_t flags = getResetCauseFlags();\par
01440 \par
01441     {\cf19 if} (flags == 0)\par
01442     \{\par
01443         {\cf19 return} RESET_UNKNOWN;\par
01444     \}\par
01445 \par
01446     {\cf20 // Check for multiple causes}\par
01447     uint8_t count = 0;\par
01448     {\cf19 if} (flags & RESET_CAUSE_POWER_ON)\par
01449     \{\par
01450         count++;\par
01451     \}\par
01452     {\cf19 if} (flags & RESET_CAUSE_EXTERNAL)\par
01453     \{\par
01454         count++;\par
01455     \}\par
01456     {\cf19 if} (flags & RESET_CAUSE_BROWN_OUT)\par
01457     \{\par
01458         count++;\par
01459     \}\par
01460     {\cf19 if} (flags & RESET_CAUSE_WATCHDOG)\par
01461     \{\par
01462         count++;\par
01463     \}\par
01464 \par
01465     {\cf19 if} (count > 1)\par
01466     \{\par
01467         {\cf19 return} RESET_MULTIPLE;\par
01468     \}\par
01469 \par
01470     {\cf20 // Single cause}\par
01471     {\cf19 if} (flags & RESET_CAUSE_POWER_ON)\par
01472     \{\par
01473         {\cf19 return} RESET_POWER_ON;\par
01474     \}\par
01475     {\cf19 if} (flags & RESET_CAUSE_EXTERNAL)\par
01476     \{\par
01477         {\cf19 return} RESET_EXTERNAL;\par
01478     \}\par
01479     {\cf19 if} (flags & RESET_CAUSE_BROWN_OUT)\par
01480     \{\par
01481         {\cf19 return} RESET_BROWN_OUT;\par
01482     \}\par
01483     {\cf19 if} (flags & RESET_CAUSE_WATCHDOG)\par
01484     \{\par
01485         {\cf19 return} RESET_WATCHDOG;\par
01486     \}\par
01487 \par
01488     {\cf19 return} RESET_UNKNOWN;\par
01489 \}\par
01490 \par
01491 uint8_t Scheduler::getResetCauseFlags()\par
01492 \{\par
01493 {\cf21 #if defined(__AVR__)}\par
01494     {\cf19 return} GPIOR0;\par
01495 {\cf21 #else}\par
01496     {\cf19 return} 0;  {\cf20 // Not available on non-AVR platforms}\par
01497 {\cf21 #endif}\par
01498 \}\par
01499 \par
01500 {\cf18 bool} Scheduler::wasResetCause(ResetCause cause) \{ {\cf19 return} getResetCause() == cause; \}\par
01501 \par
01502 {\cf18 bool} Scheduler::getTaskStats(uint8_t task_id, TaskStats &stats)\par
01503 \{\par
01504     Task *task = getTask(task_id);\par
01505     {\cf19 if} (!task)\par
01506     \{\par
01507         {\cf19 return} {\cf17 false};\par
01508     \}\par
01509 \par
01510     stats.taskId = task->getId();\par
01511     stats.name = task->getName();\par
01512     stats.state = {\cf17 static_cast<}uint8_t{\cf17 >}(task->getState());\par
01513     stats.periodMs = task->getPeriod();\par
01514     stats.priority = task->getPriority();\par
01515     stats.runCount = task->runCount;\par
01516     stats.maxExecTimeUs = task->maxExecTimeUs;      {\cf20 // 16-bit max execution time}\par
01517     stats.totalExecTimeUs = task->runCount * task->avgExecTimeUs;    {\cf20 // Calculate total from avg * count}\par
01518     stats.stackUsage = 0;         {\cf20 // Still placeholder - requires stack monitoring}\par
01519     stats.delayCount = task->delayCount;           {\cf20 // Task delay count}\par
01520     stats.maxDelayMs = task->maxDelayMs;           {\cf20 // Maximum delay experienced}\par
01521     {\cf19 return} {\cf17 true};\par
01522 \}\par
01523 \par
01524 {\cf18 bool} Scheduler::getSystemMemoryInfo(SystemMemoryInfo &info)\par
01525 \{\par
01526     info.freeRam = getFreeMemory();\par
01527     info.totalRam = 2048;    {\cf20 // AVR typical}\par
01528     {\cf20 // Heap size (bytes) from end of .bss to current break value (if any)}\par
01529 {\cf21 #if defined(__AVR__)}\par
01530     {\cf17 extern} {\cf18 char} __bss_end;\par
01531     {\cf17 extern} {\cf18 char} *__brkval;\par
01532     {\cf19 if} (__brkval)\par
01533     \{\par
01534         info.heapSize = (uint16_t)((uint16_t)__brkval - (uint16_t)&__bss_end);\par
01535     \}\par
01536     {\cf19 else}\par
01537     \{\par
01538         info.heapSize = 0;\par
01539     \}\par
01540 {\cf21 #else}\par
01541     info.heapSize = 0;\par
01542 {\cf21 #endif}\par
01543     info.largestBlock = 0;   {\cf20 // Not tracked}\par
01544     info.heapFragments = 0;  {\cf20 // Not tracked}\par
01545 {\cf21 #if defined(__AVR__)}\par
01546     {\cf20 // Approximate stack usage based on canary region}\par
01547     {\cf17 extern} {\cf18 char} __bss_end;\par
01548     {\cf17 extern} {\cf18 char} *__brkval;\par
01549     uint16_t lower = (uint16_t)(__brkval ? __brkval : &__bss_end);\par
01550     uint16_t upper = (uint16_t)RAMEND;\par
01551     uint16_t approxUsed = measure_stack_used();\par
01552     {\cf17 extern} uint8_t *g_canary_start; {\cf17 extern} uint8_t *g_canary_end;\par
01553     uint16_t windowSize = 0;\par
01554     {\cf19 if} (g_canary_start && g_canary_end && g_canary_end >= g_canary_start)\par
01555     \{\par
01556         windowSize = (uint16_t)(g_canary_end - g_canary_start + 1);\par
01557     \}\par
01558     {\cf19 else}\par
01559     \{\par
01560         windowSize = (upper >= lower) ? (upper - lower + 1) : 0;\par
01561     \}\par
01562     info.stackSize = windowSize;\par
01563     info.stackUsed = (approxUsed > windowSize) ? windowSize : approxUsed;\par
01564     info.stackFree = (info.stackUsed >= info.stackSize) ? 0 : (info.stackSize - info.stackUsed);\par
01565 {\cf21 #else}\par
01566     info.stackSize = 0;\par
01567     info.stackUsed = 0;\par
01568     info.stackFree = 0;\par
01569 {\cf21 #endif}\par
01570     info.totalTasks = taskCount;\par
01571     {\cf20 // Sum estimated task memory (struct size + subscription bitfield)}\par
01572     uint16_t taskMem = 0;\par
01573     TaskNode *tn = taskHead;\par
01574     {\cf19 while} (tn)\par
01575     \{\par
01576         {\cf19 if} (tn->task)\par
01577         \{\par
01578             taskMem += tn->task->getTaskStructSize();\par
01579             taskMem += {\cf17 sizeof}(tn->task->subscribedTopics);\par
01580         \}\par
01581         tn = tn->next;\par
01582     \}\par
01583     info.taskMemory = taskMem;\par
01584     info.activeMessages = msgCount;  {\cf20 // Provide actual active message count}\par
01585     {\cf20 // Approximate message memory: nodes + buffers across queue and free lists}\par
01586     uint16_t msgMem = 0;\par
01587     MsgNode *mn = msgHead;\par
01588     {\cf19 while} (mn)\par
01589     \{\par
01590         msgMem += {\cf17 sizeof}(MsgNode);\par
01591         msgMem += mn->payload.capacity;\par
01592         mn = mn->next;\par
01593     \}\par
01594     mn = freeHead;\par
01595     {\cf19 while} (mn)\par
01596     \{\par
01597         msgMem += {\cf17 sizeof}(MsgNode);\par
01598         msgMem += mn->payload.capacity;\par
01599         mn = mn->next;\par
01600     \}\par
01601     info.messageMemory = msgMem;\par
01602 \par
01603     {\cf20 // Flash usage from build-time constants}\par
01604 {\cf21 #ifdef BUILD_FLASH_USED}\par
01605     {\cf20 // Use real build-time values injected by build script}\par
01606     info.flashUsed = BUILD_FLASH_USED;\par
01607     info.flashFree = BUILD_FLASH_FREE;\par
01608 {\cf21 #else}\par
01609     info.flashUsed = 0;       {\cf20 // Not available at runtime}\par
01610     info.flashFree = 0;       {\cf20 // Not available at runtime}\par
01611 {\cf21 #endif}\par
01612 \par
01613     {\cf20 // EEPROM usage (approximate based on known usage)}\par
01614 {\cf21 #ifdef FSMOS_EEPROM_SIZE}\par
01615     {\cf20 // Estimate EEPROM usage based on known variables stored}\par
01616     {\cf20 // LightTask saves dim level (1 byte), other tasks may use EEPROM}\par
01617     uint16_t eepromUsed = 1;  {\cf20 // Conservative estimate}\par
01618     info.eepromUsed = eepromUsed;\par
01619     info.eepromFree = FSMOS_EEPROM_SIZE - eepromUsed;\par
01620 {\cf21 #else}\par
01621     info.eepromUsed = 0;      {\cf20 // Not available at runtime}\par
01622     info.eepromFree = 0;      {\cf20 // Not available at runtime}\par
01623 {\cf21 #endif}\par
01624     {\cf19 return} {\cf17 true};\par
01625 \}\par
01626 \par
01627 {\cf18 bool} Scheduler::getTaskMemoryInfo(uint8_t task_id, TaskMemoryInfo &info)\par
01628 \{\par
01629     Task *task = getTask(task_id);\par
01630     {\cf19 if} (!task)\par
01631     \{\par
01632         {\cf19 return} {\cf17 false};\par
01633     \}\par
01634 \par
01635     info.task_id = task->getId();\par
01636     {\cf20 // Derive struct size via virtual API; if not implemented by a task, it won't link.}\par
01637     info.task_struct_size = task->getTaskStructSize();\par
01638     info.subscription_size = {\cf17 sizeof}(task->subscribedTopics);\par
01639     info.queue_size = 0;         {\cf20 // No per-task queue in current design}\par
01640     info.total_allocated = info.task_struct_size + info.subscription_size;\par
01641     {\cf19 return} {\cf17 true};\par
01642 \}\par
01643 \par
01644 uint8_t Scheduler::getHeapFragmentation()\par
01645 \{\par
01646     {\cf19 return} 0;  {\cf20 // Placeholder}\par
01647 \}\par
01648 \par
01649 {\cf18 bool} Scheduler::getMemoryLeakStats(MemoryStats &stats)\par
01650 \{\par
01651     stats = fsmos_memory_stats;\par
01652     {\cf19 return} {\cf17 true};\par
01653 \}\par
01654 \par
01655 {\cf20 /* ================== Additional Logging Functions ================== */}\par
01656 {\cf20 // Internal helpers to reuse formatted logging logic}\par
01657 {\cf17 static} {\cf18 void} printLogHeader(Scheduler::LogLevel level)\par
01658 \{\par
01659 {\cf21 #if defined(__AVR__)}\par
01660     {\cf17 const} {\cf18 char} *level_str = {\cf22 "DEBUG"};\par
01661     {\cf19 switch} (level)\par
01662     \{\par
01663         {\cf19 case} Scheduler::LOG_INFO:\par
01664             level_str = {\cf22 "INFO"};\par
01665             {\cf19 break};\par
01666         {\cf19 case} Scheduler::LOG_WARN:\par
01667             level_str = {\cf22 "WARN"};\par
01668             {\cf19 break};\par
01669         {\cf19 case} Scheduler::LOG_ERROR:\par
01670             level_str = {\cf22 "ERROR"};\par
01671             {\cf19 break};\par
01672         {\cf19 default}:\par
01673             {\cf19 break};\par
01674     \}\par
01675     Serial.print(F({\cf22 "["}));\par
01676     Serial.print(level_str);\par
01677     Serial.print(F({\cf22 "] "}));\par
01678 {\cf21 #else}\par
01679     (void)level;\par
01680 {\cf21 #endif}\par
01681 \}\par
01682 \par
01683 {\cf17 static} {\cf18 void} logFormattedV(Scheduler::LogLevel level, {\cf17 const} __FlashStringHelper *format, va_list args)\par
01684 \{\par
01685 {\cf21 #if defined(__AVR__)}\par
01686     printLogHeader(level);\par
01687     vfprintf_P(stdout, (PGM_P)format, args);\par
01688     Serial.println();\par
01689 {\cf21 #else}\par
01690     {\cf18 char} formatted[128];\par
01691     vsnprintf(formatted, {\cf17 sizeof}(formatted), ({\cf17 const} {\cf18 char} *)format, args);\par
01692     OS.logMessage({\cf17 nullptr}, level, formatted);\par
01693 {\cf21 #endif}\par
01694 \}\par
01695 {\cf18 void} logDebugf({\cf17 const} __FlashStringHelper *format, ...)\par
01696 \{\par
01697     va_list args;\par
01698     va_start(args, format);\par
01699     logFormattedV(Scheduler::LOG_DEBUG, format, args);\par
01700     va_end(args);\par
01701 \}\par
01702 \par
01703 {\cf18 void} logInfof({\cf17 const} __FlashStringHelper *format, ...)\par
01704 \{\par
01705     va_list args;\par
01706     va_start(args, format);\par
01707     logFormattedV(Scheduler::LOG_INFO, format, args);\par
01708     va_end(args);\par
01709 \}\par
01710 \par
01711 {\cf18 void} logWarnf({\cf17 const} __FlashStringHelper *format, ...)\par
01712 \{\par
01713     va_list args;\par
01714     va_start(args, format);\par
01715     logFormattedV(Scheduler::LOG_WARN, format, args);\par
01716     va_end(args);\par
01717 \}\par
01718 \par
01719 {\cf18 void} logErrorf({\cf17 const} __FlashStringHelper *format, ...)\par
01720 \{\par
01721     va_list args;\par
01722     va_start(args, format);\par
01723     logFormattedV(Scheduler::LOG_ERROR, format, args);\par
01724     va_end(args);\par
01725 \}\par
01726 \par
01727 {\cf20 /* ================== Additional Scheduler System Methods ================== */}\par
01728 \par
01729 {\cf18 void} Scheduler::enableWatchdog(uint8_t timeout)\par
01730 \{\par
01731 {\cf21 #if defined(__AVR__)}\par
01732     wdt_enable(timeout);\par
01733 {\cf21 #endif}\par
01734 \}\par
01735 \par
01736 {\cf18 void} Scheduler::feedWatchdog()\par
01737 \{\par
01738 {\cf21 #if defined(__AVR__)}\par
01739     wdt_reset();\par
01740 {\cf21 #endif}\par
01741 \}\par
01742 \par
01743 {\cf18 void} Scheduler::logFormatted(Task *task, LogLevel level, {\cf17 const} __FlashStringHelper *format, ...)\par
01744 \{\par
01745     {\cf20 // Simplified implementation - just log the format string}\par
01746     logMessage(task, level, format);\par
01747 \}\par
01748 \par
01749 uint8_t Scheduler::getFreeQueueSlots(){\cf17  const}\par
01750 {\cf17 }\{\par
01751     {\cf19 return} {\cf17 static_cast<}uint8_t{\cf17 >}(MAX_MESSAGE_POOL_SIZE - msgCount);\par
01752 \}\par
01753 \par
01754 uint8_t Scheduler::getMostDelayingTask(){\cf17  const}\par
01755 {\cf17 }\{\par
01756     uint8_t mostDelayingTaskId = 0;\par
01757     uint16_t maxDelayCount = 0;\par
01758 \par
01759     TaskNode *current = taskHead;\par
01760     {\cf19 while} (current != {\cf17 nullptr})\par
01761     \{\par
01762         {\cf19 if} (current->task && current->task->getDelayCount() > maxDelayCount)\par
01763         \{\par
01764             maxDelayCount = current->task->getDelayCount();\par
01765             mostDelayingTaskId = current->task->getId();\par
01766         \}\par
01767         current = current->next;\par
01768     \}\par
01769 \par
01770     {\cf19 return} mostDelayingTaskId;\par
01771 \}\par
01772 \par
01773 {\cf18 bool} Scheduler::allocateMsgNodesChunk()\par
01774 \{\par
01775     {\cf19 if} (totalNodes >= MAX_MESSAGE_POOL_SIZE)\par
01776     \{\par
01777         {\cf19 return} {\cf17 false};\par
01778     \}\par
01779 \par
01780     {\cf20 // Allocate up to 4 nodes, but don\'92t exceed hard cap}\par
01781     uint8_t canAdd = {\cf17 static_cast<}uint8_t{\cf17 >}(MAX_MESSAGE_POOL_SIZE - totalNodes);\par
01782     uint8_t toAdd = (canAdd >= 4) ? 4 : canAdd;\par
01783     {\cf19 for} (uint8_t i = 0; i < toAdd; i++)\par
01784     \{\par
01785         MsgNode *n = (MsgNode *)malloc({\cf17 sizeof}(MsgNode));\par
01786         {\cf19 if} (!n)\par
01787         \{\par
01788             {\cf20 // Allocation failed; stop early}\par
01789             {\cf19 break};\par
01790         \}\par
01791         {\cf20 // Initialize node payload to safe defaults}\par
01792         n->next = freeHead;\par
01793         n->payload.targetTaskId = 0;\par
01794         n->payload.msg.type = 0;\par
01795         n->payload.msg.topic = 0;\par
01796         n->payload.msg.arg = 0;\par
01797         n->payload.msg.refCount = 0;\par
01798         n->payload.buffer = {\cf17 nullptr};\par
01799         n->payload.capacity = 0;\par
01800         freeHead = n;\par
01801         totalNodes++;\par
01802     \}\par
01803     {\cf19 return} {\cf17 true};\par
01804 \}\par
01805 \par
01806 {\cf18 bool} Scheduler::enqueueQueuedMessage(uint8_t targetTaskId, uint8_t topic, uint8_t type, uint16_t arg)\par
01807 \{\par
01808     {\cf19 if} (msgCount >= MAX_MESSAGE_POOL_SIZE)\par
01809     \{\par
01810         {\cf19 return} {\cf17 false};\par
01811     \}\par
01812 \par
01813     {\cf19 if} (!freeHead)\par
01814     \{\par
01815         allocateMsgNodesChunk();\par
01816         {\cf19 if} (!freeHead)\par
01817         \{\par
01818             {\cf19 return} {\cf17 false};\par
01819         \}\par
01820     \}\par
01821 \par
01822     MsgNode *node = freeHead;\par
01823     freeHead = freeHead->next;\par
01824 \par
01825     QueuedMessage &slot = node->payload;\par
01826     slot.targetTaskId = targetTaskId;\par
01827     slot.msg.type = type;\par
01828     slot.msg.topic = topic;\par
01829     slot.msg.arg = arg;\par
01830     slot.msg.refCount = 0;\par
01831 \par
01832     node->next = {\cf17 nullptr};\par
01833     {\cf19 if} (msgTail)\par
01834     \{\par
01835         msgTail->next = node;\par
01836         msgTail = node;\par
01837     \}\par
01838     {\cf19 else}\par
01839     \{\par
01840         msgHead = msgTail = node;\par
01841     \}\par
01842     msgCount++;\par
01843     {\cf19 return} {\cf17 true};\par
01844 \}\par
01845 \par
01846 {\cf18 bool} Scheduler::dequeueQueuedMessage(QueuedMessage &out)\par
01847 \{\par
01848     {\cf19 if} (msgCount == 0)\par
01849     \{\par
01850         {\cf19 return} {\cf17 false};\par
01851     \}\par
01852     MsgNode *node = msgHead;\par
01853     msgHead = node->next;\par
01854     {\cf19 if} (!msgHead)\par
01855     \{\par
01856         msgTail = {\cf17 nullptr};\par
01857     \}\par
01858     out = node->payload;\par
01859     {\cf20 // Node is not recycled here to avoid in-flight overwrite; caller should recycle}\par
01860     msgCount--;\par
01861     {\cf19 return} {\cf17 true};\par
01862 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
FsmOS.h File Reference\par \pard\plain 
{\tc\tcl2 \v FsmOS.h}
{\xe \v FsmOS.h}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A lightweight cooperative task scheduler for Arduino. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <Arduino.h>}\par
{\f2 #include <stdarg.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <util/atomic.h>}\par
{\f2 #include <new>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for FsmOS.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "FsmOS_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "FsmOS_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TaskNode}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Node structure for {\b Task} linked list. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MemoryStats}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory tracking statistics. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TaskStats}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} execution statistics. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ResetInfo}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
System reset information. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SystemMemoryInfo}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
System memory information. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TaskMemoryInfo}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Task} memory information. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SharedMsg}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Smart pointer-like wrapper for MsgData with reference counting. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MsgDataPool}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory pool for efficient MsgData allocation. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b LinkedQueue< T >}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lightweight, interrupt-safe linked queue. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b LinkedQueue< T >::Node}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Node} structure for linked list. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Mutex}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Mutex} for cooperative task synchronization. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Semaphore}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Semaphore} for resource counting and synchronization. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Task}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base class for all tasks in FsmOS. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Scheduler}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Core scheduler and task manager for FsmOS. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Scheduler::QueuedMessage}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Scheduler::MsgNode}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ATOMIC_BLOCK}(type)\~ for (uint8_t _ab_once = 1; _ab_once; _ab_once = 0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ATOMIC_RESTORESTATE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FSMOS_STACK_CANARY_MARGIN}\~ 32\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Safety margin (bytes) to keep between stack canary and current stack pointer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOPIC_BITFIELD_SIZE}\~ 16\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Topic bitfield configuration. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_TOPICS}\~ 16\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_MESSAGE_POOL_SIZE}\~ 32\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Forward declaration for {\b Scheduler} class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RESET_CAUSE_EXTERNAL}\~ 0x01\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reset cause flag constants from MCUSR register. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RESET_CAUSE_BROWN_OUT}\~ 0x02\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brown-out Reset flag (fallback) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RESET_CAUSE_POWER_ON}\~ 0x04\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Power-on Reset flag (fallback) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RESET_CAUSE_WATCHDOG}\~ 0x08\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Watchdog Reset flag (fallback) }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef uint16_t {\b TopicBitfield}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Timer8} = TimerT< uint8_t >\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
8-bit timer for short durations (0-255ms) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Timer16} = TimerT< uint16_t >\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
16-bit timer for medium durations (0-65535ms) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Timer32} = TimerT< uint32_t >\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
32-bit timer for long durations (0-4294967295ms) }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ResetCause} \{ {\b RESET_UNKNOWN} = 0
, {\b RESET_POWER_ON}
, {\b RESET_EXTERNAL}
, {\b RESET_BROWN_OUT}
, {\b RESET_WATCHDOG}
, {\b RESET_MULTIPLE}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reset cause enumeration for Optiboot reset flags. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > struct {\b __attribute__} ((packed)) TimerT\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory-optimized template-based timer for specific duration ranges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __attribute__} ((packed)) MsgData\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Message data structure for inter-task communication. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logDebugf} (const __FlashStringHelper *format,...)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default per-task message production budget. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logInfof} (const __FlashStringHelper *format,...)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log an info message with formatting. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logWarnf} (const __FlashStringHelper *format,...)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log a warning message with formatting. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logErrorf} (const __FlashStringHelper *format,...)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Log an error message with formatting. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const uint8_t {\b DEFAULT_TASK_MESSAGE_BUDGET} = 1\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base class for all tasks in FsmOS. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Scheduler} {\b OS}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Global scheduler instance. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const uint16_t {\b DEFAULT_TASK_PERIOD} = 100\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default task period in milliseconds. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const uint16_t {\b MIN_TASK_PERIOD} = 1\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minimum allowed task period in milliseconds. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const uint16_t {\b MAX_TASK_PERIOD} = 65535\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum allowed task period in milliseconds. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A lightweight cooperative task scheduler for Arduino. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Aykut \'D6zdemir {\f2 aykutozdemirgyte@gmail.com} \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
2025-10-02\par
}}FsmOS provides a simple, memory-efficient task scheduler for Arduino, supporting cooperative multitasking, message passing, and system monitoring.\par
Key features:{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Cooperative task scheduling with configurable periods\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Inter-task communication through messages and events\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Dynamic task creation and deletion\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Memory management and monitoring\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
System diagnostics and profiling\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Logging system with multiple levels\par}
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
This library is designed for AVR-based Arduino boards but includes partial support for other architectures.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
1.3.0 - Major refactoring and code organization \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
2025 Aykut \'D6zdemir {\f2 aykutozdemirgyte@gmail.com} \par
}}}{
Definition in file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ATOMIC_BLOCK\:FsmOS.h}
{\xe \v FsmOS.h\:ATOMIC_BLOCK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ATOMIC_BLOCK( type)\~ for (uint8_t _ab_once = 1; _ab_once; _ab_once = 0)}}
\par
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b FsmOS.h}.}\par
}
{\xe \v ATOMIC_RESTORESTATE\:FsmOS.h}
{\xe \v FsmOS.h\:ATOMIC_RESTORESTATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ATOMIC_RESTORESTATE}}
\par
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b FsmOS.h}.}\par
}
{\xe \v FSMOS_STACK_CANARY_MARGIN\:FsmOS.h}
{\xe \v FsmOS.h\:FSMOS_STACK_CANARY_MARGIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FSMOS_STACK_CANARY_MARGIN\~ 32}}
\par
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Safety margin (bytes) to keep between stack canary and current stack pointer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Prevents corruption of active stack frames and ISR stacks \par
}}}{
Definition at line {\b 58} of file {\b FsmOS.h}.}\par
}
{\xe \v MAX_MESSAGE_POOL_SIZE\:FsmOS.h}
{\xe \v FsmOS.h\:MAX_MESSAGE_POOL_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_MESSAGE_POOL_SIZE\~ 32}}
\par
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Forward declaration for {\b Scheduler} class. }}\par
{
Definition at line {\b 92} of file {\b FsmOS.h}.}\par
}
{\xe \v MAX_TOPICS\:FsmOS.h}
{\xe \v FsmOS.h\:MAX_TOPICS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_TOPICS\~ 16}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b FsmOS.h}.}\par
}
{\xe \v RESET_CAUSE_BROWN_OUT\:FsmOS.h}
{\xe \v FsmOS.h\:RESET_CAUSE_BROWN_OUT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RESET_CAUSE_BROWN_OUT\~ 0x02}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Brown-out Reset flag (fallback) }}\par
{
Definition at line {\b 186} of file {\b FsmOS.h}.}\par
}
{\xe \v RESET_CAUSE_POWER_ON\:FsmOS.h}
{\xe \v FsmOS.h\:RESET_CAUSE_POWER_ON}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RESET_CAUSE_POWER_ON\~ 0x04}}
\par
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Power-on Reset flag (fallback) }}\par
{
Definition at line {\b 187} of file {\b FsmOS.h}.}\par
}
{\xe \v RESET_CAUSE_WATCHDOG\:FsmOS.h}
{\xe \v FsmOS.h\:RESET_CAUSE_WATCHDOG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RESET_CAUSE_WATCHDOG\~ 0x08}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Watchdog Reset flag (fallback) }}\par
{
Definition at line {\b 188} of file {\b FsmOS.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v Timer16\:FsmOS.h}
{\xe \v FsmOS.h\:Timer16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b Timer16} =  TimerT<uint16_t>}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
16-bit timer for medium durations (0-65535ms) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Uses 4 bytes total memory, ideal for most timing needs \par
}{
Definition at line {\b 275} of file {\b FsmOS.h}.}\par
}
{\xe \v Timer32\:FsmOS.h}
{\xe \v FsmOS.h\:Timer32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b Timer32} =  TimerT<uint32_t>}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
32-bit timer for long durations (0-4294967295ms) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Uses 8 bytes total memory, for very long timing requirements \par
}{
Definition at line {\b 281} of file {\b FsmOS.h}.}\par
}
{\xe \v Timer8\:FsmOS.h}
{\xe \v FsmOS.h\:Timer8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b Timer8} =  TimerT<uint8_t>}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
8-bit timer for short durations (0-255ms) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Uses 2 bytes total memory, ideal for debouncing and short delays \par
}{
Definition at line {\b 269} of file {\b FsmOS.h}.}\par
}
{\xe \v TopicBitfield\:FsmOS.h}
{\xe \v FsmOS.h\:TopicBitfield}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef uint16_t {\b TopicBitfield}}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b FsmOS.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
FsmOS.h\par \pard\plain 
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00032 {\cf21 #ifndef FSMOS_H}\par
00033 {\cf21 #define FSMOS_H}\par
00034 \par
00035 {\cf20 /* ================== Core Dependencies ================== */}\par
00036 {\cf21 #include <Arduino.h>}\par
00037 {\cf21 #include <stdarg.h>}\par
00038 {\cf21 #include <stdint.h>}\par
00039 {\cf21 #include <util/atomic.h>}  {\cf20 // For ATOMIC_BLOCK}\par
00040 \par
00041 {\cf21 #include <new>}  {\cf20 // For placement new operator}\par
00042 \par
00043 {\cf21 #if defined(__AVR__)}\par
00044 {\cf21 #include <avr/io.h>}   {\cf20 // For GPIOR0 and MCUSR}\par
00045 {\cf21 #include <avr/wdt.h>}  {\cf20 // For watchdog timer}\par
00046 {\cf21 #else}\par
00047 {\cf20 // Fallback for non-AVR platforms}\par
00048 {\cf21 #define ATOMIC_BLOCK(type) for (uint8_t _ab_once = 1; _ab_once; _ab_once = 0)}\par
00049 {\cf21 #define ATOMIC_RESTORESTATE}\par
00050 {\cf21 #endif}\par
00051 \par
00052 {\cf20 // ================== Stack Canary Configuration ==================}\par
00057 {\cf21 #ifndef FSMOS_STACK_CANARY_MARGIN}\par
00058 {\cf21 #define FSMOS_STACK_CANARY_MARGIN 32}\par
00059 {\cf21 #endif}\par
00060 \par
00069 {\cf21 #ifndef TOPIC_BITFIELD_SIZE}\par
00070 {\cf21 #define TOPIC_BITFIELD_SIZE 16  }{\cf20 // Default: 16-bit bitfield}\par
00071 {\cf21 #endif}\par
00072 \par
00073 {\cf20 // Bitfield type selection based on define}\par
00074 {\cf21 #if TOPIC_BITFIELD_SIZE <= 8}\par
00075 {\cf17 typedef} uint8_t TopicBitfield;\par
00076 {\cf21 #define MAX_TOPICS 8}\par
00077 {\cf21 #elif TOPIC_BITFIELD_SIZE <= 16}\par
00078 {\cf17 typedef} uint16_t TopicBitfield;\par
00079 {\cf21 #define MAX_TOPICS 16}\par
00080 {\cf21 #elif TOPIC_BITFIELD_SIZE <= 32}\par
00081 {\cf17 typedef} uint32_t TopicBitfield;\par
00082 {\cf21 #define MAX_TOPICS 32}\par
00083 {\cf21 #else}\par
00084 {\cf21 #error "TOPIC_BITFIELD_SIZE must be 8, 16, or 32"}\par
00085 {\cf21 #endif}\par
00086 \par
00087 {\cf20 /* ================== Forward Declarations ================== */}\par
00088 {\cf17 class }Task;       \par
00089 {\cf17 class }Scheduler;  \par
00090 {\cf20 // ================== Message Queue Constants (must appear before use) ==================}\par
00091 {\cf21 #ifndef MAX_MESSAGE_POOL_SIZE}\par
00092 {\cf21 #define MAX_MESSAGE_POOL_SIZE 32}\par
00093 {\cf21 #endif}\par
00094 \par
00095 {\cf20 /* ================== Task Node Structure ================== */}\par
00100 {\cf17 struct }TaskNode\par
00101 \{\par
00102     Task *task;           \par
00103     TaskNode *next;       \par
00104 \par
00105     TaskNode(Task *t) : task(t), next(nullptr) \{\}\par
00106 \};\par
00107 \par
00108 {\cf20 /* ================== Additional Types and Structures ================== */}\par
00114 {\cf17 struct }MemoryStats\par
00115 \{\par
00116     uint32_t total_allocated;  \par
00117     uint32_t total_freed;      \par
00118     uint32_t peak_usage;       \par
00119     uint32_t current_usage;    \par
00120 \};\par
00121 \par
00127 {\cf17 struct }TaskStats\par
00128 \{\par
00129     uint8_t taskId;              \par
00130     {\cf17 const} __FlashStringHelper *name;             \par
00131     uint8_t state;                \par
00132     uint16_t periodMs;           \par
00133     uint8_t priority;             \par
00134     uint32_t runCount;           \par
00135     uint32_t maxExecTimeUs;    \par
00136     uint32_t totalExecTimeUs;  \par
00137     uint16_t stackUsage;         \par
00138     uint16_t delayCount;         \par
00139     uint16_t maxDelayMs;         \par
00140 \};\par
00141 \par
00147 {\cf17 struct }ResetInfo\par
00148 \{\par
00149     uint8_t resetReason;       \par
00150     uint32_t resetTime;        \par
00151     uint16_t watchdogTimeout;  \par
00152     uint8_t lastTaskId;       \par
00153 \par
00154     {\cf20 // Optiboot reset flag information}\par
00155     uint8_t optibootResetFlags;  \par
00156     uint8_t optibootResetCause;  \par
00157 \};\par
00158 \par
00164 {\cf17 enum} ResetCause\par
00165 \{\par
00166     RESET_UNKNOWN = 0,  \par
00167     RESET_POWER_ON,     \par
00168     RESET_EXTERNAL,     \par
00169     RESET_BROWN_OUT,    \par
00170     RESET_WATCHDOG,     \par
00171     RESET_MULTIPLE      \par
00172 \};\par
00173 \par
00179 {\cf21 #if defined(__AVR__)}\par
00180 {\cf21 #define RESET_CAUSE_EXTERNAL (1 << EXTRF)  }\par
00181 {\cf21 #define RESET_CAUSE_BROWN_OUT (1 << BORF)  }\par
00182 {\cf21 #define RESET_CAUSE_POWER_ON (1 << PORF)   }\par
00183 {\cf21 #define RESET_CAUSE_WATCHDOG (1 << WDRF)   }\par
00184 {\cf21 #else}\par
00185 {\cf21 #define RESET_CAUSE_EXTERNAL 0x01   }\par
00186 {\cf21 #define RESET_CAUSE_BROWN_OUT 0x02  }\par
00187 {\cf21 #define RESET_CAUSE_POWER_ON 0x04   }\par
00188 {\cf21 #define RESET_CAUSE_WATCHDOG 0x08   }\par
00189 {\cf21 #endif}\par
00190 \par
00196 {\cf17 struct }SystemMemoryInfo\par
00197 \{\par
00198     uint16_t freeRam;        \par
00199     uint16_t totalRam;       \par
00200     uint16_t heapSize;       \par
00201     uint16_t largestBlock;   \par
00202     uint8_t heapFragments;   \par
00203     uint16_t stackSize;      \par
00204     uint16_t stackUsed;      \par
00205     uint16_t stackFree;      \par
00206     uint8_t totalTasks;      \par
00207     uint16_t taskMemory;     \par
00208     uint8_t activeMessages;  \par
00209     uint16_t messageMemory;  \par
00210     uint16_t flashUsed;      \par
00211     uint16_t flashFree;      \par
00212     uint16_t eepromUsed;     \par
00213     uint16_t eepromFree;     \par
00214 \};\par
00215 \par
00221 {\cf17 struct }TaskMemoryInfo\par
00222 \{\par
00223     uint8_t task_id;             \par
00224     uint16_t task_struct_size;   \par
00225     uint16_t subscription_size;  \par
00226     uint16_t queue_size;         \par
00227     uint16_t total_allocated;    \par
00228 \};\par
00229 \par
00230 {\cf20 /* ================== Timer System ================== */}\par
00244 {\cf17 template} <{\cf17 typename} T>\par
00245 {\cf17 struct }__attribute__((packed)) TimerT\par
00246 \{\par
00247     T startMs = 0;     \par
00248     T durationMs = 0;  \par
00249 \par
00255     {\cf18 void} startTimer(T d);\par
00256 \par
00262     [[nodiscard]] {\cf18 bool} isExpired() {\cf17 const};\par
00263 \};\par
00264 \par
00269 {\cf17 using }Timer8 = TimerT<uint8_t>;\par
00270 \par
00275 {\cf17 using }Timer16 = TimerT<uint16_t>;\par
00276 \par
00281 {\cf17 using }Timer32 = TimerT<uint32_t>;\par
00282 \par
00283 {\cf20 /* ================== Message System ================== */}\par
00294 {\cf17 struct }__attribute__((packed)) MsgData\par
00295 \{\par
00296     uint8_t type;       \par
00297     uint8_t topic;      \par
00298     uint16_t arg;       \par
00299     uint8_t refCount;   \par
00300 \};\par
00301 \par
00313 {\cf17 class }SharedMsg\par
00314 \{\par
00315 {\cf17 public}:\par
00320     SharedMsg();\par
00321 \par
00327     {\cf17 explicit} SharedMsg(MsgData *data);\par
00328 \par
00334     SharedMsg({\cf17 const} SharedMsg &other);\par
00335 \par
00342     SharedMsg &operator=({\cf17 const} SharedMsg &other);\par
00343 \par
00348     ~SharedMsg();\par
00349 \par
00354     MsgData *getData() {\cf17 const};\par
00355 \par
00360     MsgData *operator->() {\cf17 const};\par
00361 \par
00366     {\cf18 bool} isValid() {\cf17 const};\par
00367 \par
00368 {\cf17 private}:\par
00369     MsgData *msgData;  \par
00370     {\cf18 void} release();     \par
00371 \};\par
00372 \par
00383 {\cf17 class }MsgDataPool\par
00384 \{\par
00385 {\cf17 public}:\par
00390     MsgDataPool();\par
00391 \par
00396     ~MsgDataPool();\par
00397 \par
00403     MsgData *allocate();\par
00404 \par
00410     {\cf18 void} deallocate(MsgData *msg);\par
00411 \par
00416     {\cf18 void} updateAdaptiveLimit();\par
00417 \par
00422     uint8_t getPoolSize() {\cf17 const};\par
00423 \par
00428     uint8_t getPoolLimit() {\cf17 const};\par
00429 \par
00434     uint8_t getCurrentInUse() {\cf17 const};\par
00435 \par
00441     {\cf18 bool} initialize();\par
00442 \par
00443 {\cf17 private}:\par
00444     MsgData *pool;           \par
00445     uint8_t poolSize;        \par
00446     uint8_t poolLimit;       \par
00447     uint8_t currentInUse;    \par
00448     uint8_t nextFree;        \par
00449 \};\par
00450 \par
00451 {\cf20 /* ================== Data Structures ================== */}\par
00463 {\cf17 template} <{\cf17 typename} T>\par
00464 {\cf17 class }LinkedQueue\par
00465 \{\par
00466 {\cf17 public}:\par
00470     {\cf17 struct }Node\par
00471     \{\par
00472         T data;      \par
00473         Node *next;  \par
00474     \};\par
00475 \par
00480     LinkedQueue();\par
00481 \par
00486     ~LinkedQueue();\par
00487 \par
00493     LinkedQueue(LinkedQueue &&other) {\cf17 noexcept};\par
00494 \par
00500     {\cf18 void} push({\cf17 const} T &item);\par
00501 \par
00507     {\cf18 bool} pop(T &item);\par
00508 \par
00513     {\cf18 bool} isEmpty() {\cf17 const};\par
00514 \par
00519     uint8_t getSize() {\cf17 const};\par
00520 \par
00521 {\cf17 private}:\par
00522     Node *head;     \par
00523     Node *tail;     \par
00524     uint8_t count;  \par
00525 \};\par
00526 \par
00527 {\cf20 /* ================== Synchronization Primitives ================== */}\par
00540 {\cf17 class }Mutex\par
00541 \{\par
00542 {\cf17 public}:\par
00547     Mutex();\par
00548 \par
00554     [[nodiscard]] {\cf18 bool} tryLock(uint8_t task_id);\par
00555 \par
00561     {\cf18 void} unlock(uint8_t task_id);\par
00562 \par
00567     [[nodiscard]] {\cf18 bool} isLocked() {\cf17 const};\par
00568 \par
00573     uint8_t getOwner() {\cf17 const};\par
00574 \par
00575 {\cf17 private}:\par
00576     {\cf17 volatile} {\cf18 bool} locked;       \par
00577     {\cf17 volatile} uint8_t owner_id;  \par
00578 \};\par
00579 \par
00590 {\cf17 class }Semaphore\par
00591 \{\par
00592 {\cf17 public}:\par
00598     Semaphore(uint8_t initial_count, uint8_t max_count);\par
00599 \par
00605     [[nodiscard]] {\cf18 bool} wait(uint8_t task_id);\par
00606 \par
00611     {\cf18 void} signal();\par
00612 \par
00617     uint8_t getCount() {\cf17 const};\par
00618 \par
00623     uint8_t getMaxCount() {\cf17 const};\par
00624 \par
00625 {\cf17 private}:\par
00626     {\cf17 volatile} uint8_t count;  \par
00627     uint8_t max_count;       \par
00628 \};\par
00629 \par
00630 {\cf20 /* ================== Task System ================== */}\par
00648 {\cf17 const} uint8_t DEFAULT_TASK_MESSAGE_BUDGET = 1;\par
00649 \par
00653 {\cf17 class }Task\par
00654 \{\par
00655 {\cf17 public}:\par
00661     {\cf17 explicit} Task({\cf17 const} __FlashStringHelper *name = {\cf17 nullptr});\par
00662 \par
00667     {\cf17 virtual} ~Task();\par
00668 \par
00672     {\cf17 static} uint16_t getCreatedInstanceCount() \{ {\cf19 return} createdInstanceCount; \}\par
00673 \par
00674     {\cf20 // Task lifecycle}\par
00680     {\cf17 virtual} {\cf18 void} on_start() \{\}\par
00681 \par
00687     {\cf17 virtual} {\cf18 void} step() = 0;\par
00688 \par
00694     {\cf17 virtual} {\cf18 void} on_stop() \{\}\par
00695 \par
00702     {\cf17 virtual} {\cf18 void} on_msg({\cf17 const} MsgData &msg) \{\}\par
00703 \par
00704     {\cf20 // Task control}\par
00709     {\cf18 void} start();\par
00710 \par
00715     {\cf18 void} stop();\par
00716 \par
00721     {\cf18 void} suspend();\par
00722 \par
00727     {\cf18 void} resume();\par
00728 \par
00733     {\cf18 void} terminate();\par
00734 \par
00735     {\cf20 // Task configuration}\par
00741     {\cf18 void} setPeriod(uint16_t period_ms);\par
00742 \par
00747     uint16_t getPeriod() {\cf17 const};\par
00748 \par
00749     {\cf20 // Task priority}\par
00754     {\cf17 enum} Priority\par
00755     \{\par
00756         PRIORITY_LOWEST = 0,    \par
00757         PRIORITY_LOW = 1,       \par
00758         PRIORITY_NORMAL = 2,    \par
00759         PRIORITY_HIGH = 3,      \par
00760         PRIORITY_HIGHEST = 4,   \par
00761         PRIORITY_CRITICAL = 5,  \par
00762         PRIORITY_REALTIME = 6,  \par
00763         PRIORITY_SYSTEM = 7,    \par
00764         PRIORITY_MAX = 15       \par
00765     \};\par
00766 \par
00772     {\cf18 void} setPriority(Priority priority);\par
00773 \par
00779     {\cf18 void} setPriority(uint8_t priority);\par
00780 \par
00785     uint8_t getPriority() {\cf17 const};\par
00786 \par
00792     {\cf18 void} setMaxMessageBudget(uint8_t budget);\par
00793 \par
00801     {\cf17 virtual} uint8_t getMaxMessageBudget(){\cf17  const }\{ {\cf19 return} DEFAULT_TASK_MESSAGE_BUDGET; \}\par
00802 \par
00807     {\cf17 virtual} uint16_t getTaskStructSize(){\cf17  const }\{ {\cf19 return} {\cf17 sizeof}(*this); \}\par
00808 \par
00809 {\cf17 protected}:\par
00814     uint8_t getConfiguredMessageBudget(){\cf17  const }\{ {\cf19 return} maxMessageBudget; \}\par
00815 \par
00816     {\cf20 // Task state}\par
00820     {\cf17 enum} State\par
00821     \{\par
00822         INACTIVE,   \par
00823         ACTIVE,     \par
00824         SUSPENDED,  \par
00825         TERMINATED  \par
00826     \};\par
00827 \par
00832     State getState() {\cf17 const};\par
00833 \par
00838     {\cf18 void} setState(State newState);\par
00839 \par
00845     {\cf18 bool} checkState(State expected) {\cf17 const};\par
00846 \par
00851     {\cf18 bool} isActive() {\cf17 const};\par
00852 \par
00857     {\cf18 bool} isInactive() {\cf17 const};\par
00858 \par
00859     {\cf20 // Task identification}\par
00864     uint8_t getId() {\cf17 const};\par
00865 \par
00870     {\cf17 const} __FlashStringHelper *getName() {\cf17 const};\par
00871 {\cf17 public}:\par
00875     {\cf17 static} {\cf17 const} __FlashStringHelper *readTaskName({\cf17 const} Task *t) \{ {\cf19 return} t ? t->getName() : {\cf17 nullptr}; \}\par
00876 {\cf17 protected}:\par
00877 \par
00882     {\cf18 void} setName({\cf17 const} __FlashStringHelper *name);\par
00883 \par
00884     {\cf20 // Message handling}\par
00890     {\cf18 void} subscribe(uint8_t topic)\par
00891     \{\par
00892         {\cf19 if} (topic < MAX_TOPICS)\par
00893         \{\par
00894             subscribedTopics |= ({\cf17 static_cast<}TopicBitfield{\cf17 >}(1) << topic);\par
00895         \}\par
00896     \}\par
00897 \par
00902     {\cf18 void} unsubscribe(uint8_t topic)\par
00903     \{\par
00904         {\cf19 if} (topic < MAX_TOPICS)\par
00905         \{\par
00906             subscribedTopics &= ~({\cf17 static_cast<}TopicBitfield{\cf17 >}(1) << topic);\par
00907         \}\par
00908     \}\par
00909 \par
00915     {\cf18 bool} isSubscribedToTopic(uint8_t topic){\cf17  const}\par
00916 {\cf17     }\{\par
00917         {\cf19 if} (topic >= MAX_TOPICS)\par
00918         \{\par
00919             {\cf19 return} {\cf17 false};\par
00920         \}\par
00921         {\cf19 return} (subscribedTopics & ({\cf17 static_cast<}TopicBitfield{\cf17 >}(1) << topic)) != 0;\par
00922     \}\par
00923 \par
00928     uint8_t getTopicCount(){\cf17  const}\par
00929 {\cf17     }\{\par
00930 {\cf21 #if TOPIC_BITFIELD_SIZE <= 8}\par
00931         {\cf19 return} __builtin_popcount({\cf17 static_cast<}uint8_t{\cf17 >}(subscribedTopics));\par
00932 {\cf21 #elif TOPIC_BITFIELD_SIZE <= 16}\par
00933         {\cf19 return} __builtin_popcount({\cf17 static_cast<}uint16_t{\cf17 >}(subscribedTopics));\par
00934 {\cf21 #else}\par
00935         {\cf19 return} __builtin_popcountl({\cf17 static_cast<}{\cf18 unsigned} {\cf18 long}{\cf17 >}(subscribedTopics));\par
00936 {\cf21 #endif}\par
00937     \}\par
00938 \par
00946     {\cf18 void} publish(uint8_t topic, uint8_t type, uint16_t arg = 0);\par
00947 \par
00954     {\cf18 void} tell(uint8_t task_id, uint8_t type, uint16_t arg = 0);\par
00955 \par
00956     {\cf20 // Logging}\par
00961     {\cf18 void} log({\cf17 const} __FlashStringHelper *msg);\par
00962 \par
00967     {\cf18 void} logDebug({\cf17 const} __FlashStringHelper *msg);\par
00968 \par
00973     {\cf18 void} logInfo({\cf17 const} __FlashStringHelper *msg);\par
00974 \par
00979     {\cf18 void} logWarn({\cf17 const} __FlashStringHelper *msg);\par
00980 \par
00985     {\cf18 void} logError({\cf17 const} __FlashStringHelper *msg);\par
00986 \par
00987     {\cf20 // Timer utility methods}\par
00995     {\cf17 template} <{\cf17 typename} T>\par
00996     T createTimerTyped(uint32_t duration_ms) {\cf17 const};\par
00997 \par
01002     {\cf18 void} processMessages();\par
01003 \par
01004     {\cf20 // Task timing monitoring methods}\par
01009     uint16_t getDelayCount() {\cf17 const};\par
01010 \par
01015     uint16_t getMaxDelay() {\cf17 const};\par
01016 \par
01021     uint32_t getScheduledTime() {\cf17 const};\par
01022 \par
01027     uint32_t getActualStartTime() {\cf17 const};\par
01028 \par
01029 {\cf17 private}:\par
01030     {\cf17 friend} {\cf17 class }Scheduler;\par
01031 \par
01032     uint16_t remainingTime = 0;  \par
01033     uint16_t periodMs = 1;       \par
01034     uint8_t taskId = 0;     \par
01035     uint8_t stateAndPriority = 0; \par
01036     {\cf17 const} __FlashStringHelper *name;       \par
01037 \par
01038     {\cf20 // Minimalist task statistics (RAM optimized)}\par
01039     uint16_t runCount = 0;           \par
01040     uint16_t maxExecTimeUs = 0;      \par
01041     uint16_t avgExecTimeUs = 0;      \par
01042 \par
01043     {\cf20 // Task timing monitoring}\par
01044     uint32_t scheduledTime = 0;      \par
01045     uint32_t actualStartTime = 0;    \par
01046     uint16_t delayCount = 0;         \par
01047     uint16_t maxDelayMs = 0;         \par
01048 \par
01049     TopicBitfield subscribedTopics = 0;   \par
01050 \par
01051     {\cf20 // Scheduler gating: maximum messages this task may produce in a single step()}\par
01052     uint8_t maxMessageBudget = 0;\par
01053 \par
01054     {\cf20 // Global count of created Task instances (for diagnostics/pool sizing hints)}\par
01055     {\cf17 static} uint16_t createdInstanceCount;\par
01056 \};\par
01057 \par
01058 {\cf20 /* ================== Scheduler System ================== */}\par
01073 {\cf17 class }Scheduler\par
01074 \{\par
01075 {\cf17 public}:\par
01080     Scheduler();\par
01081 \par
01086     ~Scheduler();\par
01087 \par
01088     {\cf20 // Task management}\par
01095     {\cf18 bool} add(Task *task);\par
01096 \par
01102     {\cf18 bool} remove(Task *task);\par
01103 \par
01108     {\cf18 void} removeAll();\par
01109 \par
01115     Task *getTask(uint8_t task_id);\par
01116 \par
01121     uint8_t getTaskCount(){\cf17  const }\{ {\cf19 return} taskCount; \}\par
01122 \par
01127     uint16_t getMaxTasks() {\cf17 const};\par
01128 \par
01129     {\cf20 // System control}\par
01134     {\cf18 void} begin();\par
01135 \par
01140     {\cf18 void} loopOnce();\par
01141 \par
01146     {\cf18 void} loop();\par
01147 \par
01152     {\cf18 void} stop();\par
01153 \par
01154     {\cf20 // Message system}\par
01162     {\cf18 void} publishMessage(uint8_t topic, uint8_t type, uint16_t arg = 0);\par
01163 \par
01170     {\cf18 void} sendMessage(uint8_t task_id, uint8_t type, uint16_t arg = 0);\par
01171 \par
01175     uint8_t getFreeQueueSlots() {\cf17 const};\par
01176 \par
01177     {\cf20 // System monitoring}\par
01182     uint32_t now() {\cf17 const};\par
01183 \par
01189     uint16_t getFreeMemory() {\cf17 const};\par
01190 \par
01191     {\cf20 // Logging system}\par
01195     {\cf17 enum} LogLevel\par
01196     \{\par
01197         LOG_DEBUG = 0,  \par
01198         LOG_INFO = 1,   \par
01199         LOG_WARN = 2,   \par
01200         LOG_ERROR = 3   \par
01201     \};\par
01202 \par
01208     {\cf18 void} setLogLevel(LogLevel level);\par
01209 \par
01216     {\cf18 void} logMessage(Task *task, LogLevel level, {\cf17 const} {\cf18 char} *msg);\par
01217     {\cf18 void} logMessage(Task *task, LogLevel level, {\cf17 const} __FlashStringHelper *msg);\par
01218 \par
01219     {\cf20 // System callbacks}\par
01225     {\cf18 void} onTick();\par
01226 \par
01227     {\cf20 // Additional diagnostic methods}\par
01233     {\cf18 bool} getResetInfo(ResetInfo &info);\par
01234 \par
01240     ResetCause getResetCause();\par
01241 \par
01247     uint8_t getResetCauseFlags();\par
01248 \par
01254     {\cf18 bool} wasResetCause(ResetCause cause);\par
01255 \par
01262     {\cf18 bool} getTaskStats(uint8_t task_id, TaskStats &stats);\par
01263 \par
01269     {\cf18 bool} getSystemMemoryInfo(SystemMemoryInfo &info);\par
01270 \par
01277     {\cf18 bool} getTaskMemoryInfo(uint8_t task_id, TaskMemoryInfo &info);\par
01278 \par
01283     uint8_t getHeapFragmentation();\par
01284 \par
01290     {\cf18 bool} getMemoryLeakStats(MemoryStats &stats);\par
01291 \par
01292     {\cf20 // Additional system methods}\par
01293 \par
01299     {\cf18 void} enableWatchdog(uint8_t timeout);\par
01300     {\cf18 void} feedWatchdog();\par
01301 \par
01310     {\cf18 void} logFormatted(Task *task, LogLevel level, {\cf17 const} __FlashStringHelper *format, ...);\par
01311 \par
01312     {\cf20 // Task timing monitoring}\par
01317     uint8_t getMostDelayingTask() {\cf17 const};\par
01318 \par
01319 {\cf17 private}:\par
01320     TaskNode *taskHead = {\cf17 nullptr};          \par
01321     TaskNode *taskTail = {\cf17 nullptr};          \par
01322     {\cf20 // Preallocated node pool (initialized on first add)}\par
01323     TaskNode *freeTaskNodeHead = {\cf17 nullptr};  \par
01324     {\cf18 bool} taskNodePoolInitialized = {\cf17 false};  \par
01325     uint16_t taskNodePoolCapacity = 0;     \par
01326     uint8_t taskCount = 0;                 \par
01327     uint8_t nextTaskId = 1;                \par
01328 \par
01329     MsgDataPool msgPool;  \par
01330     uint32_t systemTime;  \par
01331     {\cf18 bool} running;         \par
01332 \par
01333     LogLevel currentLogLevel;     \par
01334 \par
01335     {\cf20 // Task timing monitoring (always active)}\par
01336     uint8_t lastExecutedTaskId = 0;         \par
01337     uint32_t lastTaskEndTime = 0;           \par
01338 \par
01339     {\cf17 friend} {\cf17 class }SharedMsg;  \par
01340 \par
01345     {\cf18 void} processMessages();\par
01346 \par
01351     {\cf18 void} updateSystemTime();\par
01352 \par
01357     Task *findNextTask();\par
01358 \par
01364     {\cf18 void} executeTask(Task *task);\par
01365 \par
01366     {\cf20 // Refactored helper methods for executeTask}\par
01372     {\cf18 void} handleTaskTiming(Task *task, uint32_t currentTime);\par
01373 \par
01378     {\cf18 void} executeTaskStep(Task *task);\par
01379 \par
01385     {\cf18 void} updateTaskStatistics(Task *task, uint32_t execStart);\par
01386 \par
01391     {\cf18 void} updateTimingVariables(Task *task);\par
01392 \par
01397     {\cf18 void} checkForTerminatedTask(Task *task);\par
01398 \par
01405     {\cf18 void} logTaskDelay(Task *task, uint16_t delayMs, uint8_t causingTaskId);\par
01406 \par
01407     {\cf20 // Task iteration helpers}\par
01413     {\cf17 template}<{\cf17 typename} Func>\par
01414     {\cf18 void} forEachTask(Func func);\par
01415 \par
01422     {\cf17 template}<{\cf17 typename} Func>\par
01423     Task *findTask(Func predicate);\par
01424 \par
01425     {\cf20 // Memory management helpers}\par
01431     TaskNode *allocateTaskNode(Task *task);\par
01432 \par
01437     {\cf18 void} deallocateTaskNode(TaskNode *node);\par
01438 \par
01439     {\cf20 // Logging system helpers}\par
01445     {\cf18 void} logSystemEvent(LogLevel level, {\cf17 const} __FlashStringHelper *msg);\par
01446 \par
01452     {\cf18 void} logTaskExecution(Task *task, uint32_t execTime);\par
01453 \par
01454     {\cf20 // ================== Message Queue (bounded, no dynamic allocation) ==================}\par
01455     {\cf17 struct }QueuedMessage\par
01456     \{\par
01457         uint8_t targetTaskId;\par
01458         MsgData msg;               {\cf20 // msg.data points to buffer when dataSize > 0}\par
01459         uint8_t *buffer;           {\cf20 // retained across free-list reuse}\par
01460         uint8_t capacity;          {\cf20 // allocated size of buffer}\par
01461     \};\par
01462 \par
01463     {\cf20 // Linked-list node for queued messages}\par
01464     {\cf17 struct }MsgNode\par
01465     \{\par
01466         MsgNode *next;\par
01467         QueuedMessage payload;\par
01468     \};\par
01469 \par
01470     {\cf20 // Queue (linked list) and free-node pool}\par
01471     MsgNode *msgHead = {\cf17 nullptr};\par
01472     MsgNode *msgTail = {\cf17 nullptr};\par
01473     MsgNode *freeHead = {\cf17 nullptr};\par
01474     uint8_t msgCount = 0;        {\cf20 // number of enqueued messages}\par
01475     uint8_t totalNodes = 0;      {\cf20 // total nodes allocated into pool}\par
01476 \par
01477     {\cf20 // Grow the pool by a chunk (4 nodes) up to MAX_MESSAGE_POOL_SIZE}\par
01478     {\cf18 bool} allocateMsgNodesChunk();\par
01479 \par
01480     {\cf20 // Enqueue a message destined for a specific task}\par
01481     {\cf18 bool} enqueueQueuedMessage(uint8_t targetTaskId, uint8_t topic, uint8_t type, uint16_t arg);\par
01482 \par
01483     {\cf20 // Dequeue next message into out; returns false if empty}\par
01484     {\cf18 bool} dequeueQueuedMessage(QueuedMessage &out);\par
01485 \par
01486     {\cf20 // Dequeue and return node itself; caller is responsible for recycling node}\par
01487     {\cf18 bool} dequeueQueuedMessageNode(MsgNode *&outNode);\par
01488 \par
01489     {\cf20 // Allocate TaskNode pool on first use}\par
01490     {\cf18 bool} initializeTaskNodePool();\par
01491     {\cf20 // Acquire a node from pool}\par
01492     TaskNode *acquireTaskNode(Task *task);\par
01493     {\cf20 // Return a node to pool}\par
01494     {\cf18 void} releaseTaskNode(TaskNode *node);\par
01495 \par
01496     {\cf20 // MsgNode allocation methods}\par
01497     MsgNode *allocateMsgNode();\par
01498     {\cf18 void} deallocateMsgNode(MsgNode *node);\par
01499 \};\par
01500 \par
01501 {\cf20 /* ================== Global Scheduler Instance ================== */}\par
01508 {\cf17 extern} Scheduler OS;\par
01509 \par
01510 {\cf20 /* ================== System Constants ================== */}\par
01515 {\cf17 const} uint16_t DEFAULT_TASK_PERIOD = 100;\par
01516 \par
01521 {\cf17 const} uint16_t MIN_TASK_PERIOD = 1;\par
01522 \par
01527 {\cf17 const} uint16_t MAX_TASK_PERIOD = 65535;\par
01528 \par
01537 {\cf20 // Backward compatibility direct constants removed; use Scheduler::LogLevel}\par
01538 \par
01539 {\cf20 /* ================== Additional Scheduler Methods ================== */}\par
01546 {\cf18 void} logDebugf({\cf17 const} __FlashStringHelper *format, ...);\par
01547 \par
01554 {\cf18 void} logInfof({\cf17 const} __FlashStringHelper *format, ...);\par
01555 \par
01562 {\cf18 void} logWarnf({\cf17 const} __FlashStringHelper *format, ...);\par
01563 \par
01570 {\cf18 void} logErrorf({\cf17 const} __FlashStringHelper *format, ...);\par
01571 \par
01572 {\cf21 #endif  }{\cf20 // FSMOS_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
README.md File Reference\par \pard\plain 
{\tc\tcl2 \v README.md}
{\xe \v README.md}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
